var documenterSearchIndex = {"docs":
[{"location":"conditions/#Boundary-and-Initial-Conditions","page":"Boundary and Initial Conditions","title":"Boundary and Initial Conditions","text":"","category":"section"},{"location":"conditions/","page":"Boundary and Initial Conditions","title":"Boundary and Initial Conditions","text":"Pages = [\"conditions.md\"]","category":"page"},{"location":"conditions/","page":"Boundary and Initial Conditions","title":"Boundary and Initial Conditions","text":"addBoundaryID(bid::Int, trueOnBdry)\nboundary(var, bid, bc_type, bc_exp=0)\nreferencePoint(var, pos, val)\ninitial(var, ics)\nevalInitialConditions()","category":"page"},{"location":"conditions/#Main.Finch.addBoundaryID-Tuple{Int64, Any}","page":"Boundary and Initial Conditions","title":"Main.Finch.addBoundaryID","text":"addBoundaryID(bid::Int, trueOnBdry)\n\nCreate a new boundary region with the given ID number bid. It will be assigned to all boundary faces where the center of the face satisfies trueOnBdry. It will override any previously set ID for those faces.\n\ntrueOnBdry can be a function or a string expression of (x,y,z). Note that it only applies to faces that are known boundary faces, not interior faces.\n\n\n\n\n\n","category":"method"},{"location":"conditions/#Main.Finch.boundary","page":"Boundary and Initial Conditions","title":"Main.Finch.boundary","text":"boundary(var, bid, bc_type, bc_exp=0)\n\nSet a boundary condition for a given variable on a boundary region with this ID(bid). The type can be DIRICHLET, NEUMANN, NOBC, FLUX. bcexp can be a constant number or a string expression. NOBC type does not need a bcexp value.\n\nPossible expressions can include coordinates(x, y, z, t), callback functions, coefficients, variables, indexers, and certain other symbols such as \"normal\", \"nodeindex\", \"faceindex\".\n\n\n\n\n\n","category":"function"},{"location":"conditions/#Main.Finch.referencePoint-Tuple{Any, Any, Any}","page":"Boundary and Initial Conditions","title":"Main.Finch.referencePoint","text":"referencePoint(var, pos, val)\n\nConstrain a variable value at a single node to the given value. This is needed for certain situations where boundary conditions do not uniquely constrain a variable. The node closest to the position in pos will be used and it can be a boundary or interior node. \n\n\n\n\n\n","category":"method"},{"location":"conditions/#Main.Finch.initial-Tuple{Any, Any}","page":"Boundary and Initial Conditions","title":"Main.Finch.initial","text":"initial(var, ics)\n\nSet the initial condition for this variable. The value can be a constant number or a string expression of coordinates(x, y, z). This does not immediately set the variable values. To do so, use evalInitialConditions(), or it will be done automatically before solving.\n\n\n\n\n\n","category":"method"},{"location":"conditions/#Main.Finch.evalInitialConditions-Tuple{}","page":"Boundary and Initial Conditions","title":"Main.Finch.evalInitialConditions","text":"evalInitialConditions()\n\nEvaluate initial conditions for all variables if possible. This puts the initial values into each variable's values array. This is called automatically by the solve step, but can be done manually here.\n\n\n\n\n\n","category":"method"},{"location":"mesh/#Mesh","page":"Mesh","title":"Mesh","text":"","category":"section"},{"location":"mesh/","page":"Mesh","title":"Mesh","text":"These functions work with the mesh.","category":"page"},{"location":"mesh/","page":"Mesh","title":"Mesh","text":"Pages = [\"mesh.md\"]","category":"page"},{"location":"mesh/","page":"Mesh","title":"Mesh","text":"mesh(msh; elsperdim=5, bids=1, interval=[0,1], partitions=0)\nexportMesh(filename, format=MSH_V2)\nfiniteVolumeOrder(order)","category":"page"},{"location":"mesh/#Main.Finch.mesh-Tuple{Any}","page":"Mesh","title":"Main.Finch.mesh","text":"mesh(msh; elsperdim=5, bids=1, interval=[0,1], partitions=0)\n\nBuild or import a mesh. msh can be either a constant(LINEMESH, QUADMESH, HEXMESH) to build a mesh with the built-in simple mesh generator, or a filename for a mesh file. Currently GMSH files(.msh), either old or new versions, and MEDIT files(.mesh) are supported.\n\n\n\n\n\n","category":"method"},{"location":"mesh/#Main.Finch.exportMesh","page":"Mesh","title":"Main.Finch.exportMesh","text":"exportMesh(filename, format=MSH_V2)\n\nExport the mesh to a file with the given name. The format can be MSHV2 or MSHV4 for old and new style GMSH formats.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Main.Finch.finiteVolumeOrder-Tuple{Any}","page":"Mesh","title":"Main.Finch.finiteVolumeOrder","text":"finiteVolumeOrder(order)\n\nSet the order of flux reconstruction for FVM. For order > 1 this will cause the mesh to be subdivided into a parent/child mesh. Take this into account when designing the mesh.\n\n\n\n\n\n","category":"method"},{"location":"start/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"start/","page":"Getting started","title":"Getting started","text":"Add the Finch package using ]add \"https://github.com/paralab/Finch\"","category":"page"},{"location":"start/","page":"Getting started","title":"Getting started","text":"Alternatively, you can use a local copy of the source by navigating to  the directory containing the Finch.jl file and typing  include(\"Finch.jl\"); using .Finch","category":"page"},{"location":"start/","page":"Getting started","title":"Getting started","text":"Typically a Julia script file will be created that will perform these  tasks in this order.","category":"page"},{"location":"start/","page":"Getting started","title":"Getting started","text":"Set up configuration.\nCreate or import mesh.\nDefine variables and other entities.\nAdd boundary and initial conditions.\nInput the PDE expressions.\nSolve.\nProcess or output the results.","category":"page"},{"location":"start/","page":"Getting started","title":"Getting started","text":"See the example scripts for a more detailed illustration of the structure.","category":"page"},{"location":"reorder/#Reordering","page":"Reordering","title":"Reordering","text":"","category":"section"},{"location":"reorder/","page":"Reordering","title":"Reordering","text":"Reorder the elemental loop or nodes. Most of these assume a uniform grid of squares or cubes such as those produced by the internal mesh creation utilities.","category":"page"},{"location":"reorder/","page":"Reordering","title":"Reordering","text":"Pages = [\"reorder.md\"]","category":"page"},{"location":"reorder/","page":"Reordering","title":"Reordering","text":"mortonElements(griddim)\nhilbertElements(griddim)\ntiledElements(griddim, tiledim)\nrandomElements(seed = 17)\nmortonNodes(griddim)\nhilbertNodes(griddim)\ntiledNodes(griddim, tiledim)\nelementFirstNodes()\nrandomNodes(seed = 17)","category":"page"},{"location":"reorder/#Main.Finch.mortonElements-Tuple{Any}","page":"Reordering","title":"Main.Finch.mortonElements","text":"mortonElements(griddim)\n\nReorder the elemental loop order to a spacial Morton ordering in 2D or 3D. This currently only works for a uniform grid such as the one generated with Finch's internal utility. griddim is an array representing the elemental grid size: like [n,n] for 2D or [n,n,n] for 3D.\n\n\n\n\n\n","category":"method"},{"location":"reorder/#Main.Finch.hilbertElements-Tuple{Any}","page":"Reordering","title":"Main.Finch.hilbertElements","text":"hilbertElements(griddim)\n\nReorder the elemental loop order to a spacial Hilbert ordering in 2D or 3D. This currently only works for a uniform grid such as the one generated with Finch's internal utility. griddim is an array representing the elemental grid size: like [n,n] for 2D or [n,n,n] for 3D.\n\n\n\n\n\n","category":"method"},{"location":"reorder/#Main.Finch.tiledElements-Tuple{Any, Any}","page":"Reordering","title":"Main.Finch.tiledElements","text":"tiledElements(griddim, tiledim)\n\nReorder the elemental loop order to a spacial tiled ordering in 2D or 3D. This currently only works for a uniform grid such as the one generated with Finch's internal utility. griddim is an array representing the elemental grid size: like [n,n] for 2D or [n,n,n] for 3D. tiledim is the desired tile dimensions such as [4,4] for a 4x4 tile in 2D.\n\n\n\n\n\n","category":"method"},{"location":"reorder/#Main.Finch.randomElements","page":"Reordering","title":"Main.Finch.randomElements","text":"randomElements(seed = 17)\n\nRandomize the order of the elemental loop for testing a worst-case arrangement. The seed is for making results reproducible.\n\n\n\n\n\n","category":"function"},{"location":"reorder/#Main.Finch.mortonNodes-Tuple{Any}","page":"Reordering","title":"Main.Finch.mortonNodes","text":"mortonNodes(griddim)\n\nReorder the nodes in memory to a Morton ordering in 2D or 3D. This currently only works for a uniform grid such as the one generated with Finch's internal utility. griddim is an array representing the nodal grid size: like [n,n] for 2D or [n,n,n] for 3D.\n\n\n\n\n\n","category":"method"},{"location":"reorder/#Main.Finch.hilbertNodes-Tuple{Any}","page":"Reordering","title":"Main.Finch.hilbertNodes","text":"hilbertNodes(griddim)\n\nReorder the nodes in memory to a Hilbert ordering in 2D or 3D. This currently only works for a uniform grid such as the one generated with Finch's internal utility. griddim is an array representing the nodal grid size: like [n,n] for 2D or [n,n,n] for 3D.\n\n\n\n\n\n","category":"method"},{"location":"reorder/#Main.Finch.tiledNodes-Tuple{Any, Any}","page":"Reordering","title":"Main.Finch.tiledNodes","text":"tiledNodes(griddim, tiledim)\n\nReorder the nodes in memory to a tiled ordering in 2D or 3D. This currently only works for a uniform grid such as the one generated with Finch's internal utility. griddim is an array representing the nodal grid size: like [n,n] for 2D or [n,n,n] for 3D. tiledim is the desired tile dimensions such as [4,4] for a 4x4 tile in 2D.\n\n\n\n\n\n","category":"method"},{"location":"reorder/#Main.Finch.elementFirstNodes-Tuple{}","page":"Reordering","title":"Main.Finch.elementFirstNodes","text":"elementFirstNodes()\n\nThis is the default node ordering. Element first means the elements are given some order and the nodes are added elementwise according to that. An element's nodes are ordered according to the reference element.\n\n\n\n\n\n","category":"method"},{"location":"reorder/#Main.Finch.randomNodes","page":"Reordering","title":"Main.Finch.randomNodes","text":"randomNodes(seed = 17)\n\nRandomize nodes in memory for testing a worst-case arrangement. The seed is for making results reproducible.\n\n\n\n\n\n","category":"function"},{"location":"unstructured/#Unstructured-Meshes","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"","category":"section"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"<img src=\"../assets/images/umeshes.png\" alt=\"umeshes\" width=\"400\">","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"The script file: example-unstructured2d.jl,  example-unstructured3d.jl","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"Unstructured 2D meshes made of irregular triangles or quads are used in example-unstructured2d.jl to solve a steady state reaction diffusion equation. This demonstrates how to import .MSH files and the unstructured mesh capabilities in 2D. ","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"3D unstructured hexahedra and tetrahedra are also used for a similar equation in example-unstuctured3d.jl.","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"The following description is for the 2D case. Begin by importing and using the Finch module. Then initialize. The name here is only used when generating code files.","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"using Finch\ninitFinch(\"unstructured2d\");","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"Then set up the configuration. This example simply sets dimensionality of the domain and polynomial order of the basis function space.","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"domain(2, grid=UNSTRUCTURED)# dimension, geometry, discretization\nfunctionSpace(order=2)      # basis function polynomial order","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"Import the mesh from a .MSH file and set up all node mappings.","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"mesh(\"utriangle.msh\")     \t# Use this line for triangles\nmesh(\"uquad.msh\")         \t# Use this line for quads","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"Define the variable, test function, and other symbols.","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"u = variable(\"u\")           # same as @variable(u, SCALAR)\ntestSymbol(\"v\")             # sets the symbol for a SCALAR test function\ncoefficient(\"f\", \"(-10-(x+1)*200*pi*pi)*sin(10*pi*x)*sin(10*pi*y) + 10*pi*cos(10*pi*x)*sin(10*pi*y)\")\ncoefficient(\"k\", \"x+1\")\ncoefficient(\"C\", 10)","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"Convert the PDE","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"<div align=\"center\"><img src=\"https://render.githubusercontent.com/render/math?math=\\nabla\\cdot%20(K\\nabla%20u)-Cu=f(x)\"> </div>\n<div align=\"center\"><img src=\"https://render.githubusercontent.com/render/math?math=u(0)=u(1)=0\"> </div>","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"into the weak form","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"<div align=\"center\"><img src=\"https://render.githubusercontent.com/render/math?math=-K(\\nabla%20u,\\nabla%20v)-Cuv=(f,v)\"> </div>","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"The boundary condition is specified.","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"boundary(u, 1, DIRICHLET, \"0\") # boundary condition for BID 1 is Dirichlet with value 0","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"Then write the weak form expression in the residual form and solve for u.","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"weakForm(u, \"k*dot(grad(u), grad(v)) + C*u*v+ f*v\")\nsolve(u);","category":"page"},{"location":"unstructured/","page":"Unstructured Meshes","title":"Unstructured Meshes","text":"End things with finalizeFinch() to finish up any generated files and the log.","category":"page"},{"location":"heat/#Heat","page":"Heat","title":"Heat","text":"","category":"section"},{"location":"heat/","page":"Heat","title":"Heat","text":"<img src=\"../assets/images/heat.png\" alt=\"heat\" width=\"400\">","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"The script file: example-heat2d.jl","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"A 2D heat equation demonstrates support for time dependent problems.","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"Begin by importing and using the Finch module. Then initialize. The name here is only used when generating code files.","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"using Finch\ninitFinch(\"heat2d\");","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"Then set up the configuration. This example simply sets dimensionality of the domain and polynomial order of the basis function space.","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"domain(2)                  \t# dimension\nfunctionSpace(order=4) \t\t# polynomial order","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"Use the built-in simple mesh generator to make the mesh and set up all node mappings.","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"mesh(QUADMESH, elsperdim=10)# has 10*10 uniform, square elements","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"Define the variable, test function, and coefficient symbols.","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"u = variable(\"u\")           # make a scalar variable u\ntestSymbol(\"v\")             # sets the symbol for a test function\n\ncoefficient(\"f\", \"0.5*sin(6*pi*x)*sin(6*pi*y)\")","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"Set up the time stepper and initial conditions. This example uses a low-storage RK4. Other explicit or implicit methods are available.","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"timeStepper(LSRK4)  \t\t# Low-storage RK4\ntimeInterval(1) \t\t\t# The end time\ninitial(u, \"abs(x-0.5)+abs(y-0.5) < 0.2 ? 1 : 0\") # initial condition","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"Convert the PDE","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"<div align=\"center\"><img src=\"https://render.githubusercontent.com/render/math?math=\\frac{d}{dt}u%2BD\\Delta%20u=f\"> </div>","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"into the weak form","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"<div align=\"center\"><img src=\"https://render.githubusercontent.com/render/math?math=\\frac{d}{dt}(u,v)%2BD(\\nabla%20u,\\nabla%20v)=(f,v)\"> </div>","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"The boundary conditions are specified.","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"boundary(u, 1, DIRICHLET, 0)","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"Then write the weak form expression in the residual form. Finally, solve for u.","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"weakForm(u, \"Dt(u*v) + 0.01 * dot(grad(u),grad(v)) - f*v\")\nsolve(u);","category":"page"},{"location":"heat/","page":"Heat","title":"Heat","text":"End things with finalizeFinch() to finish up any generated files and the log.","category":"page"},{"location":"misc/#Other-Interface-Functions","page":"Other Interface Functions","title":"Other Interface Functions","text":"","category":"section"},{"location":"misc/","page":"Other Interface Functions","title":"Other Interface Functions","text":"These miscellaneous parts are part of the interface, but don't fit in the other categories.","category":"page"},{"location":"misc/","page":"Other Interface Functions","title":"Other Interface Functions","text":"Pages = [\"misc.md\"]","category":"page"},{"location":"misc/","page":"Other Interface Functions","title":"Other Interface Functions","text":"initFinch(name=\"unnamedProject\", floatType::DataType=Float64)\nfinalizeFinch()\ncustomOperator(name, handle)\ncustomOperatorFile(filename)\nVariableTransform\nvariableTransform(var1, var2, func)\ntransformVariable(xform::VariableTransform)\npreStepFunction(fun)\npostStepFunction(fun)\ncallbackFunction(fun; name=\"\", args=[], body=\"\")\nassemblyLoops(indices, parallel_type=[])\nexportCode(filename)\nimportCode(filename)\ncachesim(use)\ncachesimSolve(var)","category":"page"},{"location":"misc/#Main.Finch.initFinch","page":"Other Interface Functions","title":"Main.Finch.initFinch","text":"initFinch(name = \"unnamedProject\", floatType::DataType=Float64)\n\nThis initializes and returns the Finch state. The name of the project can be set here. T is the data type to be used for floating point data. T must be a subtype of AbstractFloat. Note that while this generally applies to data arrays relevant to the computation, some places may still use Float64, so the  corresponding conversions should be defined.\n\n\n\n\n\n","category":"function"},{"location":"misc/#Main.Finch.finalizeFinch-Tuple{}","page":"Other Interface Functions","title":"Main.Finch.finalizeFinch","text":"finalizeFinch()\n\nThis closes all files and does any other finalization steps. It does not deallocate any data, so further processing can be done after  calling this. However, using Finch functions may cause issues because files have been closed.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Main.Finch.customOperator-Tuple{Any, Any}","page":"Other Interface Functions","title":"Main.Finch.customOperator","text":"customOperator(name, handle)\n\nDefine a new symbolic operator to be used in PDE expressions. The name is the symbol that will be used in expressions. The function handle points to the  operator's function.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Main.Finch.customOperatorFile-Tuple{Any}","page":"Other Interface Functions","title":"Main.Finch.customOperatorFile","text":"customOperatorFile(filename)\n\nImport a set of symbolic operators defined in a file. The file must contain certain elements. See an example.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Main.Finch.VariableTransform","page":"Other Interface Functions","title":"Main.Finch.VariableTransform","text":"VariableTransform\n\nTwo sets of variables and a function that transforms one into the other. This is built with the variableTransform function.\n\n\n\n\n\n","category":"type"},{"location":"misc/#Main.Finch.variableTransform-Tuple{Any, Any, Any}","page":"Other Interface Functions","title":"Main.Finch.variableTransform","text":"variableTransform(var1, var2, func)\n\nDefine a function that will transform var1 into var2. var1 and var2 can be variable entities or arrays of them. The function should transform numerical values from one to the other.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Main.Finch.transformVariable-Tuple{VariableTransform}","page":"Other Interface Functions","title":"Main.Finch.transformVariable","text":"transformVariable(xform::VariableTransform)\n\nPerform a variable transformation using a previously defined transform. This can be done, for example, in a postStepFunction or in a callback function for boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Main.Finch.preStepFunction-Tuple{Any}","page":"Other Interface Functions","title":"Main.Finch.preStepFunction","text":"preStepFunction(fun)\n\nSet a function to be called before each time step, or stage for multi-stage steppers.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Main.Finch.postStepFunction-Tuple{Any}","page":"Other Interface Functions","title":"Main.Finch.postStepFunction","text":"postStepFunction(fun)\n\nSet a function to be called after each time step, or stage for multi-stage steppers.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Main.Finch.callbackFunction-Tuple{Any}","page":"Other Interface Functions","title":"Main.Finch.callbackFunction","text":"callbackFunction(fun; name=\"\", args=[], body=\"\")\n\nInclude a callback function that can be included in expressions such as the PDE or boundary conditions. A better way to do this is with the macro @callbackFunction before the function definition, which will extract the name, arguments, and body  automatically.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Main.Finch.exportCode-Tuple{Any}","page":"Other Interface Functions","title":"Main.Finch.exportCode","text":"exportCode(filename)\n\nExport all generated code including the elemental calculation and assembly loop code for all variables if available.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Main.Finch.importCode-Tuple{Any}","page":"Other Interface Functions","title":"Main.Finch.importCode","text":"importCode(filename)\n\nImport elemental calculation and assembly loop code for all variables if possible. The \"begin\", \"end\", and \"No code\" comment lines must match a specific format to  properly match them to the variables, so do not modify those lines from the exported code.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Main.Finch.cachesim-Tuple{Any}","page":"Other Interface Functions","title":"Main.Finch.cachesim","text":"cachesim(use)\n\nToggle the cache simulator target. Set use=true to use the cachesim target. If not using cachesim, don't use this function.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Main.Finch.cachesimSolve-Tuple{Any}","page":"Other Interface Functions","title":"Main.Finch.cachesimSolve","text":"cachesimSolve(var)\n\nWhen using the cache simulator target, this is used instead of solve().\n\n\n\n\n\n","category":"method"},{"location":"bratu/#Bratu-equation","page":"Bratu equation","title":"Bratu equation","text":"","category":"section"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"<img src=\"../assets/images/bratu.png\" alt=\"Bratu\" width=\"400\">","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"The script file: example-bratu1d.jl","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"A 1D Bratu equation. This demonstrates the nonlinear solver capability using either symbolic or automatic differentiation. It also demonstrates using indexed variables.","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"Begin by importing and using the Finch module. Then initialize. The name here is only used when generating code files.","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"using Finch\ninitFinch(\"bratu1d\");","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"Then set up the configuration. This example simply sets dimensionality of the domain and polynomial order of the basis function space.","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"domain(1)                  \t# dimension\nfunctionSpace(order=2) \t\t# polynomial order","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"Use the built-in simple mesh generator to make the mesh and set up all node mappings.","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"mesh(LINEMESH, elsperdim=50) # 50 uniform line segments","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"Define the variable, test function, and coefficient symbols.","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"u = variable(\"u\", type=VAR_ARRAY, index=ind) # upper branch\nl = variable(\"l\", type=VAR_ARRAY, index=ind) # lower branch\ntestSymbol(\"v\")\n\ncoefficient(\"C\", cvals, type=VAR_ARRAY)","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"Set an initial guess for the nonlinear iteration.","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"initial(u, init_str)\ninitial(l, \"0.1*sin(pi*x)\")","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"The boundary conditions are specified.","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"boundary(u, 1, DIRICHLET, 0)\nboundary(l, 1, DIRICHLET, 0)","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"Set up the linearization and iteration parameters.","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"# linearize automatically using AD for the derivative\nnonlinear(maxIters=100, relativeTol=1e-8, absoluteTol=1e-8, derivative=\"AD\")","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"OR","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"# linearize automatically using symbolic derivatives\nnonlinear(maxIters=100, relativeTol=1e-8, absoluteTol=1e-8, derivative=\"symbolic\")","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"Then write the weak form expression in the residual form. ","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"weakForm(u, \"-grad(u[ind])*grad(v) + C[ind]*exp(u[ind])*v\")\nweakForm(l, \"-grad(l[ind])*grad(v) + C[ind]*exp(l[ind])*v\")","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"Finally, solve.","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"solve(u)\nsolve(l)","category":"page"},{"location":"bratu/","page":"Bratu equation","title":"Bratu equation","text":"End things with finalizeFinch() to finish up any generated files and the log.","category":"page"},{"location":"poisson1d/#D-Poisson","page":"1D Poisson","title":"1D Poisson","text":"","category":"section"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"<img src=\"../assets/images/poisson1d.png\" alt=\"poisson1d\" width=\"400\">","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"The script file: example-poisson1d.jl","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"The 1D Poisson equation with Dirichlet boundary and smooth functions is about as simple as it gets. This example demonstrates the basics of setting up a problem in Finch. A uniform discretization of the unit domain is used with p=4 polynomial basis function space.","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"Begin by loading the Finch module. Then initialize. The name here is only used when generating code files.","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"using Finch\ninitFinch(\"poisson1d\");","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"Then set up the configuration. This example simply sets dimensionality of the domain and polynomial order of the basis function space.","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"domain(1)                  \t# dimension\nfunctionSpace(order=4) \t\t# polynomial order","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"Use the built-in simple mesh generator to make the mesh and set up all node mappings.","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"mesh(LINEMESH, elsperdim=20)# uniform 1D mesh with 20 elements","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"Define the variable, test function, and forcing function symbols.","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"u = variable(\"u\")           # make a scalar variable u\ntestSymbol(\"v\")             # sets the symbol for a test function\ncoefficient(\"f\", \"-100*pi*pi*sin(10*pi*x)*sin(pi*x) - pi*pi*sin(10*pi*x)*sin(pi*x) + 20*pi*pi*cos(10*pi*x)*cos(pi*x)\")","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"Convert the PDE","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"<div align=\"center\"><img src=\"https://render.githubusercontent.com/render/math?math=\\Delta%20u=f(x)\"> </div>\n<div align=\"center\"><img src=\"https://render.githubusercontent.com/render/math?math=u(0)=u(1)=0\"> </div>","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"into the weak form","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"<div align=\"center\"><img src=\"https://render.githubusercontent.com/render/math?math=-(\\nabla%20u,\\nabla%20v)=(f,v)\"> </div>","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"The boundary condition is specified.","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"boundary(u, 1, DIRICHLET, 0) # boundary condition for BID 1 is Dirichlet with value 0","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"Then write the weak form expression in the residual form. Finally, solve for u.","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"weakForm(u, \"-grad(u)*grad(v) - f*v\")\nsolve(u);","category":"page"},{"location":"poisson1d/","page":"1D Poisson","title":"1D Poisson","text":"End things with finalizeFinch() to finish up any generated files and the log.","category":"page"},{"location":"datatypes/#Data-types","page":"Data types","title":"Data types","text":"","category":"section"},{"location":"datatypes/","page":"Data types","title":"Data types","text":"The data type used for many of the integer and floating point arrays  can be set when initializing Finch. The floating point type must be a  subtype of AbstractFloat. Most of the arrays used in computation, such  as variable value arrays and the global linear system, will hold this  type of data.","category":"page"},{"location":"datatypes/","page":"Data types","title":"Data types","text":"To set a type other than the defalt Float64, pass the desired type to initFinch(\"projectName\", myFloatType).","category":"page"},{"location":"datatypes/","page":"Data types","title":"Data types","text":"Note that some parts of the computation may involve default types like  Float64 and Int, so mixed arithmetic operations and conversions should be  defined. In particular, Finch's use of MPI is not yet configured to  communicate custom data types for which isbitstype(T) is false,  so unexpected conversions may occur when using MPI.","category":"page"},{"location":"datatypes/","page":"Data types","title":"Data types","text":"Pages = [\"datatypes.md\"]","category":"page"},{"location":"elasticity/#Linear-Elasticity","page":"Linear Elasticity","title":"Linear Elasticity","text":"","category":"section"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"<img src=\"../assets/images/elasticity.png\" alt=\"elasticity\" width=\"400\">","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"The script file: example-elasticity.jl","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"A 3D linear elasticity equation that models the gravity induced deflection of a beam that is fixed at one end. This example demonstrates the use of vector valued variables, coefficients, and function spaces. It also introduces mixed Dirichlet and Neumann boundary conditions.","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Begin by importing and using the Finch module. Then initialize. The name here is only used when generating code files.","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"using Finch\ninitFinch(\"elasticity\");","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Then set up the configuration. This example simply sets dimensionality of the domain and polynomial order of the basis function space.","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"domain(1)                  \t# dimension\nfunctionSpace(order=4) \t\t# polynomial order","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Use the built-in simple mesh generator to make the mesh and set up all node mappings.","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"n = [10,4,4]; # The numbers of elements in each dimension. 10x4x4 elements\nbounds = [0,1,0,0.2,0,0.2]; # The limits of the domain. A narrow beam.\n\n# 3D mesh defined by n and interval above with two boundary regions.\nmesh(HEXMESH, elsperdim=n, bids=2, interval=bounds) ","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Define the variable, test function, and coefficient symbols.","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"u = variable(\"u\", type=VECTOR)\ntestSymbol(\"v\", type=VECTOR)\n\ncoefficient(\"mu\", \"x>0.5 ? 0.2 : 10\") # discontinuous mu\ncoefficient(\"lambda\", 1.25)\ncoefficient(\"f\", [\"0\",\"0\",\"-0.1\"], type=VECTOR) # gravitational force","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Convert the PDE into the weak form","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"<div align=\"center\"><img src=\"https://render.githubusercontent.com/render/math?math=((\\lambda%20\\nabla%20\\cdot%20uI%2B\\mu%20(\\nabla%20u%2B\\nabla%20u^{T})):\\nabla%20v))=(f\\cdot%20v)\"> </div>","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"The boundary conditions are specified.","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"boundary(u, 1, DIRICHLET, [0,0,0]) # x=0\nboundary(u, 2, NEUMANN, [0,0,0])   # other","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Then write the weak form expression in the residual form. Finally, solve for u.","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"weakForm(u, \"inner( (lambda * div(u) .* [1 0 0; 0 1 0; 0 0 1] + mu .* (grad(u) + transpose(grad(u)))), grad(v)) - dot(f,v)\")\nsolve(u);","category":"page"},{"location":"elasticity/","page":"Linear Elasticity","title":"Linear Elasticity","text":"End things with finalizeFinch() to finish up any generated files and the log.","category":"page"},{"location":"indexed/#Indexed-variables","page":"Indexed variables","title":"Indexed variables","text":"","category":"section"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"<img src=\"../assets/images/addiff1dindexed.png\" alt=\"addiff1dindexed\" width=\"400\">","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"The Julia script: example-addiff1d-indexed.jl","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"When solving a large number of equations with the same form, but different values, this feature greatly simplifies the input process and generated code. It also presents the possibility of arranging the assembly loops in different ways. The example shown here may not be the most meaningful case, but is easy to understand. It is an advection diffusion equation with a range of advection speeds and diffusion rates. It is solved using the finite volume method with upwinding for the advective flux. Since the equations are the same for each set of values, the variables are indexed in a single expression.","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"Begin by importing and using the Finch module. Then initialize. The name here is only used when generating code files.","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"using Finch\ninitFinch(\"FVadvection2d\");","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"Then set up the configuration. This example sets dimensionality of the domain and the solver type(FV).","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"domain(2) \t\t# dimension\nsolverType(FV)\t# FV for finite volume\ntimeStepper(RK4)# time stepper","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"Use the built-in simple mesh generator to make the mesh and set up all node mappings.","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"n = 60 # number of elements in each direction\nmesh(LINEMESH, elsperdim=n, bids=2)","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"Before defining any variables, set up the indices using the index() command. At the same time, it will be convenient to build corresponding arrays of expressions for initial and boundary conditions. This has been omitted here for clarity.","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"nspeeds = 5 # number of different advection speeds\nndiffs = 4  # number of diffusion rates\nspeed = index(\"speed\", range = [1,nspeeds])\ndiff = index(\"diff\", range = [1,ndiffs])","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"Define the variable and coefficient symbols using the type keyword VARARRAY and the previously defined index objects. The indexed coefficients will also need the type VARARRAY.","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"u = variable(\"u\", type=VAR_ARRAY, location=CELL, index=[speed, diff])\n\ncoefficient(\"a\", speeds, type=VAR_ARRAY) # advection velocity\ncoefficient(\"d\", diffs, type=VAR_ARRAY) # diffusion rate","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"The PDE must be in a conservation form for finite volume. Note the [speed, diff] indices on u and the respective indices on a and d.","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"# The conservation type equation\nconservationForm(u, \"surface(upwind(a[speed],u[speed, diff]) - d[diff] * dot(grad(u[speed, diff]),normal()))\")","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"The assembly code is generated by nesting the elemental and indexed loops in the desired order. The outermost loop is first.","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"assemblyLoops([\"elements\", speed, diff])\nsolve(u);","category":"page"},{"location":"indexed/","page":"Indexed variables","title":"Indexed variables","text":"End things with finalizeFinch() to finish up any generated files and the log.","category":"page"},{"location":"equation/#Equation-Input","page":"Equation Input","title":"Equation Input","text":"","category":"section"},{"location":"equation/","page":"Equation Input","title":"Equation Input","text":"Functions related to the PDE expressions.","category":"page"},{"location":"equation/","page":"Equation Input","title":"Equation Input","text":"Pages = [\"equation.md\"]","category":"page"},{"location":"equation/","page":"Equation Input","title":"Equation Input","text":"weakForm(var, wf)\nconservationForm(var, cf)\nprintLatex(var)","category":"page"},{"location":"equation/#Main.Finch.weakForm-Tuple{Any, Any}","page":"Equation Input","title":"Main.Finch.weakForm","text":"weakForm(var, wf)\n\nWrite the weak form of the PDE in residual form. This should be an expression that is assumed to be equal to zero. var can be a variable or an array of variables. When using arrays, wf must also be an array of matching size. wf is a string expression or array of them. It can include numbers, coefficients, variables, parameters, indexers, and symbolic operators.\n\n\n\n\n\n","category":"method"},{"location":"equation/#Main.Finch.conservationForm-Tuple{Any, Any}","page":"Equation Input","title":"Main.Finch.conservationForm","text":"conservationForm(var, cf)\n\nWrite the integral conservation form of the PDE. This should be an expression that is assumed to be equal to the time derivative of the variable. Surface integrals for the flux are wrapped in surface(), and all other terms are assumed to be volume integrals for the source. Do not include the time derivative as it is implicitly assumed. var can be a variable or an array of variables. When using arrays, cf must also be an array of matching size. cf is a string expression or array of them. It can include numbers, coefficients, variables, parameters, indexers, and symbolic operators.\n\n\n\n\n\n","category":"method"},{"location":"equation/#Main.Finch.printLatex-Tuple{Any}","page":"Equation Input","title":"Main.Finch.printLatex","text":"printLatex(var)\n\nPrint a string of Latex formatted code for the symbolic layer form of the PDE. This is somewhat limited and needs to be updated to a more useful output.\n\n\n\n\n\n","category":"method"},{"location":"FVadvection/#Finite-Volume:-Advection","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"","category":"section"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"<img src=\"../assets/images/fvadvec2d.png\" alt=\"fvadvec2d\" width=\"400\">","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"The script file: example-advection1d-fv.jl,  example-advection2d-fv.jl","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"The finite volume method can also be used for some problems. One key difference is that the PDE will be input in the form of a conservation equation rather than the weak form. Also, variables used with FV should be defined as averages on cells rather than nodal values, though there is some ability to interpolate between them as needed. ","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"The following description is for the 2D case. Begin by importing and using the Finch module. Then initialize. The name here is only used when generating code files.","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"using Finch\ninitFinch(\"FVadvection2d\");","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"Then set up the configuration. This example sets dimensionality of the domain and the solver type(FV).","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"domain(2) \t\t# dimension\nsolverType(FV)\t# FV for finite volume","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"Use the built-in simple mesh generator to make the mesh and set up all node mappings.","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"n = 15 # number of elements in each direction\nmesh(QUADMESH, elsperdim=n, bids=4)","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"Define the variable and coefficient symbols. Note the use of CELL to define this variable as cell averages.","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"u = variable(\"u\", location=CELL)\n\ncoefficient(\"a\", [\"cos(pi*x/2)\",\"sin(pi*x/2)\"], type=VECTOR) # advection velocity","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"The boundary condition is specified.","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"boundary(u, 1, FLUX, \"(abs(y-0.2) < 0.11) ? sin(2*pi*t)^2 : 0\") # x=0\nboundary(u, 2, NO_BC) # x=1\nboundary(u, 3, NO_BC) # y=0\nboundary(u, 4, NO_BC) # y=1","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"The PDE must be in a conservation form.","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"# The conservation type equation\n# The \"upwind\" function applies upwinding to the term (a.n)*f with flow velocity a.\n# The optional third parameter is for tuning. Default upwind = 0, central = 1. Choose something between these.\nconservationForm([u, v, w], [\"surface(upwind(a,u))\", \"surface(upwind(a,v))\", \"surface(upwind(a,w))\"]) ","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"Here the upwind(a,u) function applies upwinding to the advective term (a.n)u with advection velocity a. An optional third parameter is for tuning. Default upwind = 0, central = 1. Choose something between these.","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"If you wish to inspect or modify the generated code, use the exportCode function. To then use the previously exported code, rather than generating new code, use importCode.","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"exportCode(\"fvad2dcode\") # exports to fvad2dcode.jl","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"Finally, solve for u.","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"solve(u);","category":"page"},{"location":"FVadvection/","page":"Finite Volume: Advection","title":"Finite Volume: Advection","text":"End things with finalizeFinch() to finish up any generated files and the log.","category":"page"},{"location":"configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"These functions are used at the beginning of your script to set up  the configuration.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Pages = [\"configuration.md\"]","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"generateFor(lang; filename=project_name, header=\"\", params...)\nuseLog(name=project_name; dir=output_dir, level=2)\ndomain(dims; shape=SQUARE, grid=UNIFORM_GRID)\nsolverType(method, backend=DEFAULT_SOLVER)\nfunctionSpace(;space=LEGENDRE, order=0, orderMin=0, orderMax=0)\nnodeType(type)\ntimeStepper(type; cfl=0)\ntimeInterval(T)\nsetSteps(dt, steps)\nlinAlgOptions(;matrixFree::Bool=false, iterative::Bool=false, method::String=\"GMRES\", pc::String=\"ILU\", maxiter::Int=0, abstol=0, reltol=1e-8, gmresRestart::Int=0, verbose::Bool=false)","category":"page"},{"location":"configuration/#Main.Finch.generateFor-Tuple{Any}","page":"Configuration","title":"Main.Finch.generateFor","text":"generateFor(lang; filename=project_name, header=\"\", params...)\n\nSpecify the generation target. Lang could be one of the included target constants:  (MATLAB, DENDRO) or the filename where the target is defined. The keyword argument filename refers to the name to be applied to the generated code. The header text  will be placed at the top of each generated code file. If the target requires  some extra parameters, those are included in params and available to the target  as a Dict{Symbol, Any}.\n\n\n\n\n\n","category":"method"},{"location":"configuration/#Main.Finch.useLog","page":"Configuration","title":"Main.Finch.useLog","text":"useLog(name=project_name; dir=output_dir, level=2)\n\nTurn on logging with the given file name and optional directory. The verbosity level can be 1(basic progress info), 2(More details about each step), or 3(everything).\n\n\n\n\n\n","category":"function"},{"location":"configuration/#Main.Finch.domain-Tuple{Any}","page":"Configuration","title":"Main.Finch.domain","text":"domain(dims; shape=SQUARE, grid=UNIFORM_GRID)\n\nSet the dimensionality of the domain. The shape(SQUARE, IRREGULAR) and  grid type(UNIFORM_GRID, UNSTRUCTURED, TREE) can be set, but may be changed when building or importing the mesh.\n\n\n\n\n\n","category":"method"},{"location":"configuration/#Main.Finch.functionSpace-Tuple{}","page":"Configuration","title":"Main.Finch.functionSpace","text":"functionSpace(;space=LEGENDRE, order=0, orderMin=0, orderMax=0)\n\nSet the polynomial order and type of polynomials for FEM. Some of these are placeholders, so only use order at this point.\n\n\n\n\n\n","category":"method"},{"location":"configuration/#Main.Finch.nodeType-Tuple{Any}","page":"Configuration","title":"Main.Finch.nodeType","text":"nodeType(type)\n\nFor FEM, set the nodal configuration within elements. The default is LOBATTO. GAUSS and UNIFORM are available, but should be used with care.\n\n\n\n\n\n","category":"method"},{"location":"configuration/#Main.Finch.timeStepper-Tuple{Any}","page":"Configuration","title":"Main.Finch.timeStepper","text":"timeStepper(type; cfl=0)\n\nSet the type of time stepping method and optionally the CFL number. Options include EULER_EXPLICIT, EULER_IMPLICIT, CRANK_NICHOLSON, RK4, LSRK4. There are some other options for specific targets, so see their documentation. If no CFL number is provided, one will be chosen based on the mesh and stepper type.\n\n\n\n\n\n","category":"method"},{"location":"configuration/#Main.Finch.timeInterval-Tuple{Any}","page":"Configuration","title":"Main.Finch.timeInterval","text":"timeInterval(T)\n\nSet the ending time for time stepping. This is overridden if time steps are manually specified.\n\n\n\n\n\n","category":"method"},{"location":"configuration/#Main.Finch.setSteps-Tuple{Any, Any}","page":"Configuration","title":"Main.Finch.setSteps","text":"setSteps(dt, steps)\n\nManually set the time steps if desired.\n\n\n\n\n\n","category":"method"},{"location":"configuration/#Main.Finch.linAlgOptions-Tuple{}","page":"Configuration","title":"Main.Finch.linAlgOptions","text":"linAlgOptions(kwargs...)\n\nSet options for solving the linear system. Matrix-free must use an iterative method. Iterative methods include GMRES or CG provided by IterativeSolvers.jl Available preconditioners are AMG and ILU provided by AlgebraicMultigrid.jl and IncompleteLU.jl. Defaults maxiter=0, abstol=0, and gmresRestart=0 will use the  corresponding defaults from IterativeSolvers.jl\n\nKeywords\n\nmatrixFree=false\niterative=false\nmethod=\"GMRES\" or \"CG\"\npc=\"ILU\" or \"AMG\" or \"NONE\"\nmaxiter::Int=0 0 will result in size(A, 2)\nabstol=0\nreltol=1e-8\ngmresRestart=0 0 will result in min(20, size(A, 2))\nverbose::Bool=false Print convergence info for each iteration.\n\n\n\n\n\n","category":"method"},{"location":"entities/#Entities","page":"Entities","title":"Entities","text":"","category":"section"},{"location":"entities/","page":"Entities","title":"Entities","text":"Entities include variables, coefficients, indices, and other objects that appear in the equations.","category":"page"},{"location":"entities/","page":"Entities","title":"Entities","text":"Pages = [\"entities.md\"]","category":"page"},{"location":"entities/","page":"Entities","title":"Entities","text":"Variable\nCoefficient\nIndexer\nvariable(name; type=SCALAR, location=NODAL, method=CG, index=nothing)\ncoefficient(name, val; type=SCALAR, location=NODAL, element_array=false)\nparameter(name, val; type=SCALAR)\nindex(name; range=[1])\ntestSymbol(symbol; type=SCALAR)","category":"page"},{"location":"entities/#Main.Finch.Variable","page":"Entities","title":"Main.Finch.Variable","text":"Variable{T<:AbstractFloat}\n\nRepresents a value that is not defined by an independent function of coordinates. Note that this does not have to be an unknown that is solved for. It can hold values that are dependent on other variables such as transformed variables, or any other value that the user has control over.\n\nThis is also useful for setting up data arrays that match those of unknowns. The values for a variable v can be directly accessed as v.values and has  dimensions [C, N] where C is the number of components (SCALAR=1, etc.) and N is  the number of nodes or cells.\n\nThis should be built with the variable function.\n\n\n\n\n\n","category":"type"},{"location":"entities/#Main.Finch.Coefficient","page":"Entities","title":"Main.Finch.Coefficient","text":"Coefficient{T<:AbstractFloat}\n\nRepresents an independent value that can be defined in terms of coordinates or assigned numerical values. Unlike variables, their values are typically not available to the user since they may be in the form of generated functions  rather than numbers.\n\nThis should be built with the coefficient function.\n\n\n\n\n\n","category":"type"},{"location":"entities/#Main.Finch.Indexer","page":"Entities","title":"Main.Finch.Indexer","text":"Indexer\n\nAn entity representing an index to be applied to a variable or coefficient. It has a  symbol that can be used in expressions, a range of integer values, and a current  value that can be accessed with I.value for an index labeled I.\n\nThis should be built with the index function.\n\n\n\n\n\n","category":"type"},{"location":"entities/#Main.Finch.variable-Tuple{Any}","page":"Entities","title":"Main.Finch.variable","text":"variable(name; type=SCALAR, location=NODAL, method=CG, index=nothing)\n\nCreate a variable entity with name that will be used in expressions. Type can be SCALAR, VECTOR, TENSOR, SYMTENSOR, or VARARRAY. Location can be NODAL or CELL. Generally nodal will be used for FEM and  cell for FVM. The method can be specified for this variable when using a mixed solver, but will otherwise be the current solver type. It the type is VAR_ARRAY, it should be indexed using a previously defined indexer or an array of indexers.\n\nNote that a variable does not have to represent an unknown. It can be used to store any value, and can be used in expressions, but does not need to be  solved for explicitly.\n\n\n\n\n\n","category":"method"},{"location":"entities/#Main.Finch.coefficient-Tuple{Any, Any}","page":"Entities","title":"Main.Finch.coefficient","text":"coefficient(name, val; type=SCALAR, location=NODAL, element_array=false)\n\nCreate a coefficient entity with name that will be used in expressions. The value can be a numerical constant, a string representing an expression of coordinates(x, y, z, t), or an array of numbers corresponding to the location. Type can be SCALAR, VECTOR, TENSOR, SYMTENSOR, or VARARRAY. Location can be NODAL or CELL. Generally nodal will be used for FEM and  cell for FVM. \n\n\n\n\n\n","category":"method"},{"location":"entities/#Main.Finch.parameter-Tuple{Any, Any}","page":"Entities","title":"Main.Finch.parameter","text":"parameter(name, val; type=SCALAR)\n\nCreate a parameter entity with name that will be used in expressions. The value is a string expression that can include coordinates(x, y, z, t) and  any variable and coefficient symbols. It is essentially a convenient object to simplify more complicated expressions. The type is not important as it will be determined by the symbolic expression it represents.\n\n\n\n\n\n","category":"method"},{"location":"entities/#Main.Finch.index-Tuple{Any}","page":"Entities","title":"Main.Finch.index","text":"index(name; range=[1])\n\nCreate an indexer entity to index variables and coefficients with a VAR_ARRAY type. The range can be an array of integers or an array with the min and max values. Though not strictly necessary, the range should start at 1 and increase consecutively. Other configurations may cause some issues in the generated code.\n\nrange=[1,2,3,4,5] is the same as range=[1,5]\n\n\n\n\n\n","category":"method"},{"location":"entities/#Main.Finch.testSymbol-Tuple{Any}","page":"Entities","title":"Main.Finch.testSymbol","text":"testSymbol(symbol; type=SCALAR)\n\nDefine a symbol for a test function when using FEM. Type can be SCALAR, VECTOR, TENSOR, or SYM_TENSOR.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples start simple and demonstrate how to use the various aspects of finch.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\"poisson1d.md\",\n         \"heat.md\",\n         \"elasticity.md\",\n         \"bratu.md\",\n         \"unstructured.md\",\n         \"FVadvection.md\",\n         \"indexed.md\"]","category":"page"},{"location":"solution/#Solution-and-Output","page":"Solution and Output","title":"Solution and Output","text":"","category":"section"},{"location":"solution/","page":"Solution and Output","title":"Solution and Output","text":"Solve and output the results.","category":"page"},{"location":"solution/","page":"Solution and Output","title":"Solution and Output","text":"Pages = [\"solution.md\"]","category":"page"},{"location":"solution/","page":"Solution and Output","title":"Solution and Output","text":"solve(var)\noutputValues(vars, filename; format=\"vtk\", ascii=false)","category":"page"},{"location":"solution/#Main.Finch.solve-Tuple{Any}","page":"Solution and Output","title":"Main.Finch.solve","text":"solve(var)\n\nEither solve the problem using an internal target, or generate all code files for an external target. Var is a variable or array of variables to solve for. The keyword arguments are for nonlinear equations which have very limited support, so generally they won't be used.\n\n\n\n\n\n","category":"method"},{"location":"solution/#Main.Finch.outputValues-Tuple{Any, Any}","page":"Solution and Output","title":"Main.Finch.outputValues","text":"outputValues(vars, filename; format=\"vtk\", ascii=false)\n\nOutput variable values to a file in a spicified format. vars can be a variable or array of variables. Possible formats are \"vtk\", \"csv\", or \"raw\" Set ascii to true to make ascii type vtk files instead of binary.\n\n\n\n\n\n","category":"method"},{"location":"#Documentation-for-Finch","page":"Documentation for Finch","title":"Documentation for Finch","text":"","category":"section"},{"location":"","page":"Documentation for Finch","title":"Documentation for Finch","text":"Finch is a domain specific language and code generation package for  partial differential equations. It is intended for people with a good  understanding of the mathematics of the finite element or finite volume  methods for solving PDEs. To make full use of Finch some knowledge of  parallel computing is needed, such as how to launch a multi-process  instance of Julia using MPI, or launching Julia with multiple threads.  See MPI.jl and  Multi-threading  for refernence.","category":"page"},{"location":"","page":"Documentation for Finch","title":"Documentation for Finch","text":"Pages = [\"start.md\", \"configuration.md\", \"mesh.md\", \"entities.md\", \"conditions.md\", \"equation.md\", \"solution.md\", \"datatypes.md\", \"reorder.md\", \"misc.md\"]","category":"page"}]
}
