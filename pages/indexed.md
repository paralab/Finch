---
title: Indexed variables
---

## Indexed variables

<img src="images/addiff1dindexed.png" alt="addiff1dindexed" width="400">

The Julia script: <a href="https://github.com/paralab/finch/blob/master/src/examples/example-addiff1d-indexed.jl">example-addiff1d-indexed.jl</a>

When solving a large number of equations with the same form, but different values, this feature greatly simplifies the input process and generated code. It also presents the possibility of arranging the assembly loops in different ways. The example shown here may not be the most meaningful case, but is easy to understand. It is an advection diffusion equation with a range of advection speeds and diffusion rates. It is solved using the finite volume method with upwinding for the advective flux. Since the equations are the same for each set of values, the variables are indexed in a single expression.

Begin by importing and using the Finch module. Then initialize. The name here is only used when generating code files.
```
using Finch
init_finch("FVadvection2d");
```
Then set up the configuration. This example sets dimensionality of the domain and the solver type(FV).
```
domain(2) 		# dimension
solverType(FV)	# FV for finite volume
timeStepper(RK4)# time stepper
```
Use the built-in simple mesh generator to make the mesh and set up all node mappings.
```
n = 60 # number of elements in each direction
mesh(LINEMESH, elsperdim=n, bids=2)
```
Before defining any variables, set up the indices using the `index()` command. At the same time, it will be convenient to build corresponding arrays of expressions for initial and boundary conditions. This has been omitted here for clarity.
```
nspeeds = 5 # number of different advection speeds
ndiffs = 4  # number of diffusion rates
speed = index("speed", range = [1,nspeeds])
diff = index("diff", range = [1,ndiffs])
```
Define the variable and coefficient symbols using the type keyword VAR_ARRAY and the previously defined index objects. The indexed coefficients will also need the type VAR_ARRAY.
```
u = variable("u", VAR_ARRAY, CELL, index = [speed, diff])

coefficient("a", astr, VAR_ARRAY) # advection velocity
coefficient("d", dstr, VAR_ARRAY) # diffusion rate
```
The PDE must be in a conservation form for finite volume. Note the `[speed, diff]` indices on u and the respective indices on a and d.
```
# The flux and source terms of the conservation equation
# F and S in the following equation:
# Dt(int(u dx)) = int(S dx) - int(F.n ds)

flux(u, "upwind(a[speed],u[speed, diff]) - d[diff] * dot(grad(u[speed, diff]),normal())")
# Note that there is no source() for this problem
```
The assembly code is generated by nesting the elemental and indexed loops in the desired order. The outermost loop is first.
```
assemblyLoops(u, ["elements", speed, diff])
solve(u);
```
End things with `finalize_finch()` to finish up any generated files and the log.