//This file was generated by Finch.

/*

*/
/**
* Main file for heat3d.
*/ 
// General
#include <iostream>
#include <fstream>
#include <point.h>
// Dendrite/Taly
#include <DendriteUtils.h>
#include <TalyEquation.h>
#include <Traversal/Analytic.h>
#include <IO/VTU.h>
#include <IMGA/IMGA.h>
#include <IMGA/Marker.h>
// Petsc
#include <PETSc/Solver/LinearSolver.h>
#include <PETSc/PetscUtils.h>
#include <PETSc/IO/petscVTU.h>
// For surface search
#include "nanoflann.hpp"

// generated
#include <heat3dEquation.h>
#include <heat3dBoundaryConditions.h>
#include <heat3dNodeData.h>
#include <heat3dInputData.h>
#include "util.h"

using namespace PETSc;

// A kd-tree index for surface search:
using surface_kd_tree_t = nanoflann::KDTreeSingleIndexAdaptor<
        nanoflann::L2_Simple_Adaptor<double, PointCloud<double>>,
        PointCloud<double>, DIM>;

int main(int argc, char* argv[]) {
    /// initialize
    dendrite_init(argc, argv);
    int rank = TALYFEMLIB::GetMPIRank();
    
    // timers //////////////////////////////////////////////////////////////////////////////
    TimerGroup<MPITimer> timers;

    std::vector<std::string>
        timer_labels = {"Total", "Setup", "Solve", "FileIO", "OctreeCreate", "KDTree"};
    std::map<std::string, int> timer_tags;
    for (int i = 0; i < timer_labels.size(); i++){
        timer_tags.insert(std::pair<std::string, int>(timer_labels[i], i));
        timers.AddTimer(timer_labels[i]);
    }
    timers.Start(timer_tags["Total"]);
    timers.Start(timer_tags["Setup"]);
    //////////////////////////////////////////////////////////////////////////////////////////
    
    /// read parameters from config.txt //////////////////////////////////////////////////////
    heat3dInputData inputData;
    std::ifstream configFile("config.txt");
    if (configFile.good()) {
        if (!inputData.ReadFromFile()) {
            throw std::runtime_error("[ERR] Error reading input data, check the config file!");
        }
        if (!inputData.CheckInputData()) {
            throw std::runtime_error("[ERR] Problem with input data, check the config file!");
        }
    } else{
        TALYFEMLIB::PrintStatus("No config.txt file found. Copy the generated config.txt into the build directory");
        return -1;
    }
    
    // Print config
    inputData.PrintInputData();
    //////////////////////////////////////////////////////////////////////////////////////////
    
    // Configuration variables
    unsigned int eleOrder = inputData.basisFunction;
    unsigned int level = inputData.meshDef.refineLevel_base;
    bool mfree = inputData.ifMatrixFree;
    
    // build the mesh ////////////////////////////////////////////////////////////////////////
    bool resume_from_checkpoint = false;
    DomainExtents domainExtents(inputData.meshDef.fullDADomain, inputData.meshDef.physDomain);
    DA *octDA = nullptr;
    DistTREE dTree;
    SubDomain subDomain(domainExtents, resume_from_checkpoint);
    
    IMGA *imga = new IMGA(domainExtents, IBM_METHOD::SBM);

    /// Load stl
    std::vector<GEOMETRY::Geometry *> curve_geoms;
    std::vector<GEOMETRY::STL *> stls; // 3D
    std::vector<GEOMETRY::MSH *> mshs; // 2D
    std::array<DENDRITE_REAL, DIM> shift;
    std::vector<GeomRefinement> ibm_refinements;

    for (const auto &geom_def : inputData.carved_out_geoms_def){
#if (DIM == 2)
        if (geom_def.type == CarvedOutGeom::Type::MESHOBJECT_2D){
            mshs.push_back(new GEOMETRY::MSH(geom_def.mesh_path, GEOMETRY::InOutTest2D::RAY_TRACING_2D));
            shift[0] = geom_def.InitialDisplacement[0];
            shift[1] = geom_def.InitialDisplacement[1];
            auto geom_retain_side = RetainSide::OUT;
            if (geom_def.outer_boundary){
                geom_retain_side = RetainSide::IN;
            }
            curve_geoms.push_back(new GEOMETRY::Geometry(mshs.back(), Point<DIM>(shift), geom_retain_side));
            ibm_refinements.emplace_back(geom_def.geomRefine);
        }
#endif
#if (DIM == 3)
        if (geom_def.type == CarvedOutGeom::Type::MESHOBJECT){
            stls.push_back(new GEOMETRY::STL(geom_def.mesh_path, GEOMETRY::InOutTest::RAY_TRACING));
            shift[0] = geom_def.InitialDisplacement[0];
            shift[1] = geom_def.InitialDisplacement[1];
            shift[2] = geom_def.InitialDisplacement[2];
            auto geom_retain_side = RetainSide::OUT;
            if (geom_def.outer_boundary){
                geom_retain_side = RetainSide::IN;
            }
            curve_geoms.push_back(new GEOMETRY::Geometry(stls.back(), Point<DIM>(shift), geom_retain_side));
            ibm_refinements.emplace_back(geom_def.geomRefine);
        }
#endif
    }
    
    for (const auto &c : curve_geoms){
        subDomain.addObject(c);
    }
    for (int i = 0; i < curve_geoms.size(); i++){
        imga->addGeometry(curve_geoms.at(i), ibm_refinements.at(i));
    }
    
    /// carving subda
    std::function<ibm::Partition(const double *, double)> functionToRetain = [&](const double *octCoords, double scale){
        return (subDomain.functionToRetain(octCoords, scale));
    };
    
    timers.Start(timer_tags["OctreeCreate"]);
    octDA = createSubDA(dTree, functionToRetain, level, eleOrder);
    subDomain.finalize(octDA, dTree.getTreePartFiltered(), domainExtents);
    util_funcs::performRefinementSubDA(octDA, dTree.getTreePartFiltered(), domainExtents, dTree, inputData, &subDomain);
    timers.Stop(timer_tags["OctreeCreate"]);
    
    TALYFEMLIB::PrintStatus("total No of nodes in the mesh = ", octDA->getGlobalNodeSz());
    
    subDomain.finalize(octDA, dTree.getTreePartFiltered(), domainExtents);
    IO::writeBoundaryElements(octDA, dTree.getTreePartFiltered(), "boundary", "subDA", domainExtents);
    SubDomainBoundary boundary(&subDomain, octDA, domainExtents);
    
    //////////////////////////////////////////////////////////////////////////////////////////
    
    // Problem specification
    static const unsigned int NUM_VARS = 1;
    DomainInfo physDomain;
    physDomain.min = inputData.meshDef.min;
    physDomain.max = inputData.meshDef.max;
    
    // Time steps (define even if no time stepping)
    unsigned int currentStep = 0;
    double currentT = 0.0;
    double dt = inputData.dt[0];
    unsigned int nSteps = inputData.nSteps[0];
    double totalT = nSteps * dt;
    TimeInfo timeInfo(0.0, inputData.dt, inputData.totalT);
    
    /// Boundary condition
    heat3dBoundaryConditions heat3dBC(&boundary, &inputData, &timeInfo);

    /// Gridfield setup
    TalyMesh<heat3dNodeData> talyMesh(octDA->getElementOrder());
    SubDomainBoundary *subDomainBoundary = &boundary;
    
    /// imga setup is not currently done. When is this needed?
    // imga->initIMGAComputation(octDA, dTree.getTreePartFiltered());
    
    /// Equation and solver setup
    Marker *elementMarker = new Marker(octDA, dTree.getTreePartFiltered(), domainExtents, imga, MarkerType::GAUSS_POINT);
    std::vector<PetscInt> dirichletNodes;
    
    /// SBM
    // timers.Start(timer_tags["SurrogateIndentify"]);
    // Vec nodalFalseElement;
    // std::vector<std::bitset<ElementMarker::MAX_ELMENT_TYPE>> elementMarkers, elementMarkerVisualize;
    // util_funcs::generateNewMarkers(octDA, dTree, domainExtents, subDomain, subDomainBoundary, imga, elementMarkers, elementMarkerVisualize, nodalFalseElement, &inputData);
    // timers.Stop(timer_tags["SurrogateIndentify"]);
    
    // Pre Calculation of true boundary mesh center points
    PointCloud<double> CenterPts;
    
    // Setup for distance function calculation in SBM
    timers.Start(timer_tags["KDTree"]);
#if (DIM == 3)
    util_funcs::GetTriangleCenter(stls,CenterPts);
#endif
#if (DIM == 2)
    util_funcs::GetLineEdgePt(mshs,CenterPts);
#endif
    
    surface_kd_tree_t kd_tree(DIM, CenterPts, {static_cast<size_t>(inputData.MaxLeaf)});
    timers.Stop(timer_tags["KDTree"]);
    
    auto heat3dEq = new TalyEquation<heat3dEquation, heat3dNodeData>
                                                (&talyMesh, octDA, dTree.getTreePartFiltered(),
                                                subDomain.domainExtents(), NUM_VARS, &timeInfo, true, subDomainBoundary,
                                                &inputData, imga, &kd_tree);
    
    heat3dEq->equation()->setBoundaryCondition(&heat3dBC);
    
    // Setup PETSc solver
    LinearSolver *heat3dSolver = setLinearSolver(heat3dEq, octDA, NUM_VARS, mfree);
    /// apply solver parameters from config.txt
    inputData.solverOptions.apply_to_petsc_options("-heat3d_");
    KSP m_ksp = heat3dSolver->ksp();
    KSPSetOptionsPrefix(m_ksp, "heat3d_");
    KSPSetFromOptions(m_ksp);
    
    // Boundary conditions
    heat3dSolver->setDirichletBoundaryCondition([&](const TALYFEMLIB::ZEROPTV &pos, int nodeID) -> Boundary {
        Boundary b;
        heat3dBC.setBoundaryConditions(b, pos);
        return b;
    });
    
    heat3dSolver->setIBMDirichletNodes(dirichletNodes);
    heat3dEq->assignIBMConstructs(imga, elementMarker->getMarkers().data());
    // heat3dEq->assignIBMConstructs(imga, elementMarkers.data());
    
    // initial condition function needs physical coordinates
    OctToPhysical octToPhys(domainExtents);
    double *pt = new double[DIM];
    
    std::function<void(const double *, double *)> initial_condition = [pt,octToPhys](const double *oct_pt, double *var) {
        pt[0] = oct_pt[0];
        pt[1] = oct_pt[1];
        pt[2] = oct_pt[2];
        octToPhys.convertCoordsToPhys(pt, 1);
        var[0] = 0.0;
    };
    // Progress meter
    int progress_step_size = 10;
    int last_progress = 0;
    TALYFEMLIB::PrintStatus("Time step progress (%) 0");
    // Set up storage used by time stepper.
    Vec prev_solution, prev_prev_solution;
    octDA->petscCreateVector(prev_solution, false, false, NUM_VARS);
    octDA->petscCreateVector(prev_prev_solution, false, false, NUM_VARS);
    // Set initial condtions.
    octDA->petscSetVectorByFunction(prev_solution, initial_condition, false, false, NUM_VARS);
    VecCopy(prev_solution, prev_prev_solution);
    heat3dEq->setVectors({VecInfo(prev_solution, NUM_VARS, 0), VecInfo(prev_prev_solution, NUM_VARS, 1)}, SYNC_TYPE::VECTOR_ONLY);
    
    timers.Stop(timer_tags["Setup"]);

    // end setup, start solve /////////////////////////////////////////////////////////////////////////////

    timers.Start(timer_tags["Solve"]);

    // Beginning time steps
    while (currentStep < nSteps) {
        currentT += dt;
        timeInfo.increment();
        heat3dEq->equation()->advanceTime(dt);
        currentStep++;
        heat3dSolver->solve();
        VecCopy(prev_solution, prev_prev_solution);
        VecCopy(heat3dSolver->getCurrentSolution(), prev_solution);
        
        if((currentStep * 100.0 / nSteps) >= (last_progress + progress_step_size)){
            last_progress += progress_step_size;
            TALYFEMLIB::PrintStatus(last_progress, "%");
        }

    }
    
    timers.Stop(timer_tags["Solve"]);



    // Output to vtk
    timers.Start(timer_tags["FileIO"]);
    static const char *varname[]{"u_1"};
    util_funcs::save_data(octDA, dTree.getTreePartFiltered(), prev_solution, inputData, timeInfo, subDomain, varname);
    timers.Stop(timer_tags["FileIO"]);

    
    timers.Stop(timer_tags["Total"]);
    timers.PrintTotalTimeSeconds();
    
    // Print time to solvetime.txt
    if(rank==0){
        double workTime = timers.GetTimer(timer_tags["Total"])->GetTotalTimeSeconds() - timers.GetTimer(timer_tags["FileIO"])->GetTotalTimeSeconds();
        std::ofstream outfile;
        
        outfile.open("solvetime.txt", std::ios_base::app); // append instead of overwrite
        outfile << workTime << "\n"; 
        outfile.close();
    }
    
    VecDestroy(&prev_solution);
    VecDestroy(&prev_prev_solution);


    delete heat3dEq;
    delete heat3dSolver;
    dendrite_finalize(octDA);
    return 0;
}   

