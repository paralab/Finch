//This file was generated by Finch.

/*

*/
#pragma once

#include <talyfem/fem/cequation.h>
#include "heat3dNodeData.h"
#include "heat3dInputData.h"
#include <heat3dBoundaryConditions.h>
#include "util.h"
#include "SBMcalc.h"
#include <DataTypes.h>
#include <Basis/MatVec.h>
#include <Basis/Vec.h>
#include <Basis/Mat.h>
#include "nanoflann.hpp"

using surface_kd_tree_t = nanoflann::KDTreeSingleIndexAdaptor<
        nanoflann::L2_Simple_Adaptor<double, PointCloud<double>>,
        PointCloud<double>, DIM>;

class heat3dEquation : public TALYFEMLIB::CEquation<heat3dNodeData> {
    
    public:
    explicit heat3dEquation(const heat3dInputData * idata, const IMGA *imga, surface_kd_tree_t *kd_tree)
            : TALYFEMLIB::CEquation<heat3dNodeData>(false, TALYFEMLIB::kAssembleGaussPoints), imga_(imga), kd_tree_(kd_tree){
        idata_ = idata;
        dt = idata->dt[0];
        currentT = 0.0;
        NUM_VARS = 1;
    }
    
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // These do nothing or redirect to other functions. Needed by talyfem? ////////////////////////
    void Solve(double dt, double t) override {
        assert(false);
    }
    void Integrands(const TALYFEMLIB::FEMElm &fe, TALYFEMLIB::ZeroMatrix<double> &Ae,
                    TALYFEMLIB::ZEROARRAY<double> &be) override {
        assert(false);
    }
    void Integrands_Ae(const TALYFEMLIB::FEMElm &fe, TALYFEMLIB::ZeroMatrix<double> &Ae, const double *h){
        Integrands_Ae(fe, Ae);
    }
    void Integrands_be(const TALYFEMLIB::FEMElm &fe, TALYFEMLIB::ZEROARRAY<double> &be, const double *h){
        Integrands_be(fe, be);
    }
    void Integrands4side_Ae(const TALYFEMLIB::FEMElm &fe, int side_idx, int id, TALYFEMLIB::ZeroMatrix<double> &Ae,
                          const double *h){
        Integrands4side_Ae(fe, side_idx, id, Ae);
    }
    void Integrands4side_be(const TALYFEMLIB::FEMElm &fe, int side_idx, int id, TALYFEMLIB::ZEROARRAY<double> &be,
                          const double *h){
        Integrands4side_be(fe, side_idx, id, be);
    }
    void ibm_Integrands4side_Ae(const TALYFEMLIB::FEMElm &fe, TALYFEMLIB::ZEROMATRIX<double> &Ae,
                                const NodeAndValues<DENDRITE_REAL> &gpinfo,
                                const TALYFEMLIB::ZEROPTV &position,
                                const TALYFEMLIB::ZEROPTV &h){
        return;
    }
    void ibm_Integrands4side_be(const TALYFEMLIB::FEMElm &fe, TALYFEMLIB::ZEROARRAY<double> &be,
                                const NodeAndValues<DENDRITE_REAL> &gpinfo,
                                const TALYFEMLIB::ZEROPTV &position,
                                const TALYFEMLIB::ZEROPTV &h){
        return;
    }
    void ibm_Integrands4side_Ae(const TALYFEMLIB::FEMElm &fe, TALYFEMLIB::ZEROMATRIX<double> &Ae,
                                const NodeAndValues<DENDRITE_REAL> &gpinfo,
                                const TALYFEMLIB::ZEROPTV &position,
                                const TALYFEMLIB::ZEROPTV &h,
                                const std::vector<double> &surface_values){
        ibm_Integrands4side_Ae(fe, Ae, gpinfo, position, h);
    }
    void ibm_Integrands4side_be(const TALYFEMLIB::FEMElm &fe, TALYFEMLIB::ZEROARRAY<double> &Ae,
                                const NodeAndValues<DENDRITE_REAL> &gpinfo,
                                const TALYFEMLIB::ZEROPTV &position,
                                const TALYFEMLIB::ZEROPTV &h,
                                const std::vector<double> &surface_values){
        ibm_Integrands4side_be(fe, Ae, gpinfo, position, h);
    }
    ///////////////////////////////////////////////////////////////////////////////////////////
    
    // Volume integrals //////////////////////////////////////////////////////////////////////
    /*
    This is called once for each quadrature point (1D???)
    Computes every element of Ae for one quadrature point.
    Will be inside this loop:
    while (fe.next_itg_pt()) {
        Integrands_Ae(fe, Ae);
    }
    
    Why do it this way?
    */
    void Integrands_Ae(const TALYFEMLIB::FEMElm &fe, TALYFEMLIB::ZeroMatrix<double> &Ae) {
        using namespace TALYFEMLIB;
        // # of dimensions: 1, 2, or 3
        // const int n_dimensions = fe.nsd(); // <- config.dimension
        const int n_dimensions = 3;
        // # of basis functions
        const int n_basis_functions = fe.nbf(); // <- refel.Np ?
        
        // (determinant of J) cross W
        const double wdetj = fe.detJxW();
        // coordinates of this point
        const ZEROPTV p = fe.position();
        
        // Evaluate coefficients for volume matrix. //
        
        for (int row = 0; row < n_basis_functions; row++) {
            for (int col = 0; col < n_basis_functions; col++) {
                ////////////////////////////////////////////////////////////////////////
                // This is generated from the input expressions
                double N = 0.0;
                N += (fe.N(row) * (wdetj * 1.5) * fe.N(col));
                N += (fe.dN(row, 0) * (wdetj * dt) * fe.dN(col, 0));
                N += (fe.dN(row, 1) * (wdetj * dt) * fe.dN(col, 1));
                N += (fe.dN(row, 2) * (wdetj * dt) * fe.dN(col, 2));
                Ae(row, col) += N;
                ////////////////////////////////////////////////////////////////////////
            }
        }
    }
    
    void Integrands_be(const TALYFEMLIB::FEMElm &fe, TALYFEMLIB::ZEROARRAY<double> &be) {
        using namespace TALYFEMLIB;
        // # of basis functions
        const int n_basis_functions = fe.nbf();
        // (determinant of J) cross W
        const double wdetj = fe.detJxW();
        // coordinates of this point
        const ZEROPTV p = fe.position();
        
        // Evaluate coefficients for volume vector. //
        double value__u_1 = p_data_->valueFEM(fe, 0);
        double value_PREV2_u_1 = p_data_->valueFEM(fe, 0 + NUM_VARS);
        
        for (int row = 0; row < n_basis_functions; row++) {
            ////////////////////////////////////////////////////////////////////////
            // This is generated from the input expressions
            double N = 0.0;
            N += (fe.N(row) * (wdetj * (2 * value__u_1)));
            N += (fe.N(row) * (wdetj * (-0.5 * value_PREV2_u_1)));
            be(row) += N;
            ////////////////////////////////////////////////////////////////////////
        }
        
    }
    
    // Surface integrals //////////////////////////////////////////////////////////////////////
    void Integrands4side_Ae(const TALYFEMLIB::FEMElm &fe, int side_idx, int id, TALYFEMLIB::ZeroMatrix<double> &Ae){
        
        // GPpos_.push_back(fe.position());
        
        /// from integral by parts, there is no Ae for the boundary term,
        /// because -[w\dot \alpha \grad T] are all known variable, and they go into the be
        /// for the weak BC
        const int nsd = DIM;
        const double Cb_e = idata_->Cb_e;
        const double wdetj= fe.detJxW();

        double elementDiameter = util_funcs::ElementSize(fe);
        double alpha = Cb_e;
        double dist2bdry[DIM];
        const double* normal = fe.surface()->normal().data();
        TALYFEMLIB::ZEROPTV trueNormal;
        
        // The position of the GP
        const ZEROPTV pt = fe.position();
        
        SBMCalc sbmCalc(fe, idata_, imga_, kd_tree_);
        sbmCalc.Dist2Geo(dist2bdry);
        sbmCalc.NormalofGeo(trueNormal, dist2bdry);
        
        // Need to find the Dirichlet boundary value.
        double boundary_value = 0.0;
        
        // The corresponding position on the true boundary
        double x_true = pt.x() + dist2bdry[0];
        double y_true = pt.y() + dist2bdry[1];
        double z_true = pt.z() + dist2bdry[2];
        
        int tmpbctype = 0;
        if (side_idx < BoundaryTypes::MAX_WALL_TYPE_BOUNDARY){
            // this is for 2 * DIM domain boundaries
            const auto &domain_def = idata_->boundary_def.at(side_idx);
            tmpbctype = domain_def.bc_type;
        }else{
            // this is for carved out boundaries
            const auto &carved_out_def = idata_->carved_out_geoms_def.at(id);
            const int bid = boundaryConditions->getBoundaryID(ZEROPTV(x_true, y_true, z_true));
            if(bid > 0){
                tmpbctype = carved_out_def.bc_type_V[bid];
            }else{
                tmpbctype = carved_out_def.bc_type_V[0];
            }
        }
        const int bcType = tmpbctype;
        
        boundary_value = 0.0;
        
        double ELEMENTDIAMETER = elementDiameter;
        double FACENORMAL1_1 = normal[0];
        double FACENORMAL1_2 = normal[1];
        double FACENORMAL1_3 = normal[2];
        double TRUENORMAL_1 = trueNormal.data()[0];
        double TRUENORMAL_2 = trueNormal.data()[1];
        double TRUENORMAL_3 = trueNormal.data()[2];
        double DIST2BDRY_1 = dist2bdry[0];
        double DIST2BDRY_2 = dist2bdry[1];
        double DIST2BDRY_3 = dist2bdry[2];
        double BOUNDARYVALUE = boundary_value;

        
        if(bcType == CarvedOutGeom::BCType::SBM){
            // Evaluate coefficients for Dirichlet boundary matrix. //

            for (int row = 0; row < fe.nbf(); row++){
                for (int col = 0; col < fe.nbf(); col++){
                    ////////////////////////////////////////////////////////////////////////
                    // This is generated from the input expressions
                    double N = 0.0;
                    N += (fe.dN(row, 0) * ((-wdetj) * FACENORMAL1_1) * fe.N(col));
                    N += (fe.dN(row, 1) * ((-wdetj) * FACENORMAL1_2) * fe.N(col));
                    N += (fe.dN(row, 2) * ((-wdetj) * FACENORMAL1_3) * fe.N(col));
                    N += (fe.N(row) * ((-wdetj) * FACENORMAL1_1) * fe.dN(col, 0));
                    N += (fe.N(row) * ((-wdetj) * FACENORMAL1_2) * fe.dN(col, 1));
                    N += (fe.N(row) * ((-wdetj) * FACENORMAL1_3) * fe.dN(col, 2));
                    N += (fe.N(row) * (wdetj * (200.0 * (1 / ELEMENTDIAMETER))) * fe.N(col));
                    N += (fe.dN(row, 0) * (wdetj * ((-DIST2BDRY_1) * FACENORMAL1_1)) * fe.dN(col, 0));
                    N += (fe.dN(row, 2) * (wdetj * ((-DIST2BDRY_1) * FACENORMAL1_3)) * fe.dN(col, 0));
                    N += (fe.dN(row, 1) * (wdetj * ((-DIST2BDRY_1) * FACENORMAL1_2)) * fe.dN(col, 0));
                    N += (fe.dN(row, 0) * (wdetj * ((200.0 * pow(DIST2BDRY_1, 2)) * (1 / ELEMENTDIAMETER))) * fe.dN(col, 0));
                    N += (fe.dN(row, 0) * (wdetj * ((-DIST2BDRY_2) * FACENORMAL1_1)) * fe.dN(col, 1));
                    N += (fe.dN(row, 1) * (wdetj * ((-DIST2BDRY_2) * FACENORMAL1_2)) * fe.dN(col, 1));
                    N += (fe.dN(row, 2) * (wdetj * ((-DIST2BDRY_2) * FACENORMAL1_3)) * fe.dN(col, 1));
                    N += (fe.dN(row, 1) * (wdetj * ((200.0 * pow(DIST2BDRY_2, 2)) * (1 / ELEMENTDIAMETER))) * fe.dN(col, 1));
                    N += (fe.dN(row, 0) * (wdetj * ((-DIST2BDRY_3) * FACENORMAL1_1)) * fe.dN(col, 2));
                    N += (fe.dN(row, 1) * (wdetj * ((-DIST2BDRY_3) * FACENORMAL1_2)) * fe.dN(col, 2));
                    N += (fe.dN(row, 2) * (wdetj * ((-DIST2BDRY_3) * FACENORMAL1_3)) * fe.dN(col, 2));
                    N += (fe.dN(row, 2) * (wdetj * ((200.0 * pow(DIST2BDRY_3, 2)) * (1 / ELEMENTDIAMETER))) * fe.dN(col, 2));
                    N += (fe.dN(row, 0) * (wdetj * ((200.0 * DIST2BDRY_1) * (1 / ELEMENTDIAMETER))) * fe.N(col));
                    N += (fe.dN(row, 1) * (wdetj * ((200.0 * DIST2BDRY_2) * (1 / ELEMENTDIAMETER))) * fe.N(col));
                    N += (fe.dN(row, 2) * (wdetj * ((200.0 * DIST2BDRY_3) * (1 / ELEMENTDIAMETER))) * fe.N(col));
                    N += (fe.N(row) * (wdetj * ((200.0 * DIST2BDRY_1) * (1 / ELEMENTDIAMETER))) * fe.dN(col, 0));
                    N += (fe.N(row) * (wdetj * ((200.0 * DIST2BDRY_2) * (1 / ELEMENTDIAMETER))) * fe.dN(col, 1));
                    N += (fe.N(row) * (wdetj * ((200.0 * DIST2BDRY_3) * (1 / ELEMENTDIAMETER))) * fe.dN(col, 2));
                    N += (fe.dN(row, 0) * (wdetj * ((200.0 * DIST2BDRY_1 * DIST2BDRY_2) * (1 / ELEMENTDIAMETER))) * fe.dN(col, 1));
                    N += (fe.dN(row, 1) * (wdetj * ((200.0 * DIST2BDRY_1 * DIST2BDRY_2) * (1 / ELEMENTDIAMETER))) * fe.dN(col, 0));
                    N += (fe.dN(row, 2) * (wdetj * ((200.0 * DIST2BDRY_1 * DIST2BDRY_3) * (1 / ELEMENTDIAMETER))) * fe.dN(col, 0));
                    N += (fe.dN(row, 0) * (wdetj * ((200.0 * DIST2BDRY_1 * DIST2BDRY_3) * (1 / ELEMENTDIAMETER))) * fe.dN(col, 2));
                    N += (fe.dN(row, 2) * (wdetj * ((200.0 * DIST2BDRY_3 * DIST2BDRY_2) * (1 / ELEMENTDIAMETER))) * fe.dN(col, 1));
                    N += (fe.dN(row, 1) * (wdetj * ((200.0 * DIST2BDRY_3 * DIST2BDRY_2) * (1 / ELEMENTDIAMETER))) * fe.dN(col, 2));
                    Ae(row, col) += N;

                    ////////////////////////////////////////////////////////////////////////
                }
            }
            
        }else if(bcType == CarvedOutGeom::BCType::NEUMANN_SBM){
            // Evaluate coefficients for Neumann boundary matrix. //

            for (int row = 0; row < fe.nbf(); row++){
                for (int col = 0; col < fe.nbf(); col++){
                    ////////////////////////////////////////////////////////////////////////
                    // This is generated from the input expressions
                    double N = 0.0;
                    N += (fe.N(row) * ((-wdetj) * FACENORMAL1_1) * fe.dN(col, 0));
                    N += (fe.N(row) * ((-wdetj) * FACENORMAL1_2) * fe.dN(col, 1));
                    N += (fe.N(row) * ((-wdetj) * FACENORMAL1_3) * fe.dN(col, 2));
                    N += (fe.N(row) * (wdetj * (pow(TRUENORMAL_1, 2) * FACENORMAL1_1)) * fe.dN(col, 0));
                    N += (fe.N(row) * (wdetj * (pow(TRUENORMAL_2, 2) * FACENORMAL1_2)) * fe.dN(col, 1));
                    N += (fe.N(row) * (wdetj * (pow(TRUENORMAL_3, 2) * FACENORMAL1_3)) * fe.dN(col, 2));
                    N += (fe.N(row) * (wdetj * (TRUENORMAL_1 * TRUENORMAL_2 * FACENORMAL1_2)) * fe.dN(col, 0));
                    N += (fe.N(row) * (wdetj * (TRUENORMAL_1 * TRUENORMAL_2 * FACENORMAL1_1)) * fe.dN(col, 1));
                    N += (fe.N(row) * (wdetj * (TRUENORMAL_3 * TRUENORMAL_1 * FACENORMAL1_3)) * fe.dN(col, 0));
                    N += (fe.N(row) * (wdetj * (TRUENORMAL_3 * TRUENORMAL_1 * FACENORMAL1_1)) * fe.dN(col, 2));
                    N += (fe.N(row) * (wdetj * (TRUENORMAL_3 * TRUENORMAL_2 * FACENORMAL1_3)) * fe.dN(col, 1));
                    N += (fe.N(row) * (wdetj * (TRUENORMAL_3 * TRUENORMAL_2 * FACENORMAL1_2)) * fe.dN(col, 2));
                    Ae(row, col) += N;

                    ////////////////////////////////////////////////////////////////////////
                }
            }
        }
    }
    
    void Integrands4side_be(const TALYFEMLIB::FEMElm &fe, int side_idx, int id, TALYFEMLIB::ZEROARRAY<double> &be){
        using namespace TALYFEMLIB;
        
        const int nsd = DIM;
        const double wdetj = fe.detJxW();
        const double Cb_e = idata_->Cb_e;
        double alpha = Cb_e;
        
        double elementDiameter = util_funcs::ElementSize(fe);
        double dist2bdry[DIM];
        const double* normal = fe.surface()->normal().data();
        TALYFEMLIB::ZEROPTV trueNormal;
        
        // The position of the GP
        const ZEROPTV pt = fe.position();

        SBMCalc sbmCalc(fe, idata_, imga_, kd_tree_);
        sbmCalc.Dist2Geo(dist2bdry);
        sbmCalc.NormalofGeo(trueNormal, dist2bdry);
        
        // Need to find the Dirichlet boundary value.
        double boundary_value = 0.0;
        
        // The corresponding position on the true boundary
        double x_true = pt.x() + dist2bdry[0];
        double y_true = pt.y() + dist2bdry[1];
        double z_true = pt.z() + dist2bdry[2];
        
        int tmpbctype = 0;
        if (side_idx < BoundaryTypes::MAX_WALL_TYPE_BOUNDARY){
            // this is for 2 * DIM domain boundaries
            const auto &domain_def = idata_->boundary_def.at(side_idx);
            tmpbctype = domain_def.bc_type;
        }else{
            // this is for carved out boundaries
            const auto &carved_out_def = idata_->carved_out_geoms_def.at(id);
            const int bid = boundaryConditions->getBoundaryID(ZEROPTV(x_true, y_true, z_true));
            if(bid > 0){
                tmpbctype = carved_out_def.bc_type_V[bid];
            }else{
                tmpbctype = carved_out_def.bc_type_V[0];
            }
        }
        const int bcType = tmpbctype;
        
        boundaryConditions->getBoundaryValue(ZEROPTV(x_true,y_true, z_true), &boundary_value);
        
        double ELEMENTDIAMETER = elementDiameter;
        double FACENORMAL1_1 = normal[0];
        double FACENORMAL1_2 = normal[1];
        double FACENORMAL1_3 = normal[2];
        double TRUENORMAL_1 = trueNormal.data()[0];
        double TRUENORMAL_2 = trueNormal.data()[1];
        double TRUENORMAL_3 = trueNormal.data()[2];
        double DIST2BDRY_1 = dist2bdry[0];
        double DIST2BDRY_2 = dist2bdry[1];
        double DIST2BDRY_3 = dist2bdry[2];
        double BOUNDARYVALUE = boundary_value;

        
        if(bcType == CarvedOutGeom::BCType::SBM){
            // Evaluate coefficients for Dirichlet boundary vector. //

            for (int row = 0; row < fe.nbf(); row++){
                ////////////////////////////////////////////////////////////////////////
                // This is generated from the input expressions
                double N = 0.0;
                N += (fe.dN(row, 0) * ((-wdetj) * (FACENORMAL1_1 * BOUNDARYVALUE)));
                N += (fe.dN(row, 1) * ((-wdetj) * (FACENORMAL1_2 * BOUNDARYVALUE)));
                N += (fe.dN(row, 2) * ((-wdetj) * (FACENORMAL1_3 * BOUNDARYVALUE)));
                N += (fe.N(row) * (wdetj * ((200.0 * BOUNDARYVALUE) * (1 / ELEMENTDIAMETER))));
                N += (fe.dN(row, 0) * (wdetj * ((200.0 * DIST2BDRY_1 * BOUNDARYVALUE) * (1 / ELEMENTDIAMETER))));
                N += (fe.dN(row, 1) * (wdetj * ((200.0 * DIST2BDRY_2 * BOUNDARYVALUE) * (1 / ELEMENTDIAMETER))));
                N += (fe.dN(row, 2) * (wdetj * ((200.0 * DIST2BDRY_3 * BOUNDARYVALUE) * (1 / ELEMENTDIAMETER))));
                be(row) += N;

                ////////////////////////////////////////////////////////////////////////
            }
            
        }else if(bcType == CarvedOutGeom::BCType::NEUMANN_SBM){
            // Evaluate coefficients for Neumann boundary vector. //

            for (int row = 0; row < fe.nbf(); row++){
                ////////////////////////////////////////////////////////////////////////
                // This is generated from the input expressions
                double N = 0.0;
                N += (fe.N(row) * ((-wdetj) * (TRUENORMAL_1 * FACENORMAL1_1 * BOUNDARYVALUE)));
                N += (fe.N(row) * ((-wdetj) * (TRUENORMAL_2 * FACENORMAL1_2 * BOUNDARYVALUE)));
                N += (fe.N(row) * ((-wdetj) * (TRUENORMAL_3 * FACENORMAL1_3 * BOUNDARYVALUE)));
                be(row) += N;

                ////////////////////////////////////////////////////////////////////////
            }
        }
    }
    
    void advanceTime(const double dti){
        currentT += dti;
    }
    
    void GetPos(std::vector<ZEROPTV> &GPpos){
        GPpos = GPpos_;
    }
    
    void setBoundaryCondition(heat3dBoundaryConditions *bcs){
      boundaryConditions = bcs;
    }
    
    protected:
    const heat3dInputData *idata_;
    heat3dBoundaryConditions *boundaryConditions;
    double dt;
    double currentT;
    unsigned int NUM_VARS;
    
    const IMGA *imga_;
    std::vector<ZEROPTV> GPpos_;
    surface_kd_tree_t *kd_tree_;
    
    ////////////////////////////////////////////////////////////////////////
    // Coefficient functions
    double genfunction_1(const TALYFEMLIB::ZEROPTV &pt, const double t){
        return exp((-(pt.z()) * pt.z()) / 0.04);
    }
    ////////////////////////////////////////////////////////////////////////
};
    

