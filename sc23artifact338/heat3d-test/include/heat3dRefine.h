//This file was generated by Finch.

/*

*/
#pragma once

#include <Traversal/Refinement.h>
#include <Boundary/SubDomainBoundary.h>

#include <utility>
#include "heat3dInputData.h"

class heat3dRefine : public Refinement{
    heat3dInputData *inputData_;
    const DomainExtents &domainExtents_;
    SubDomainBoundary *subDomainBoundary_;
    bool doCoarsen_ = false;
    std::vector<GEOMETRY::Geometry *> ibmGeoms_;

public:
    heat3dRefine(DA *octDA,
                const std::vector<TREENODE> &treePart,
                const DomainExtents &domainExtents,
                heat3dInputData *inputData,
                SubDomainBoundary *subDomainBoundary);

    heat3dRefine(DA *octDA,
                const std::vector<TREENODE> &treePart,
                const DomainExtents &domainExtents,
                heat3dInputData *inputData,
                SubDomainBoundary *subDomainBoundary,
                std::vector<GEOMETRY::Geometry *> ibmGeoms,
                bool doCoarsen = false);
    ot::OCT_FLAGS::Refine getRefineFlags(TALYFEMLIB::FEMElm &fe, const std::vector<TALYFEMLIB::ZEROPTV> &coords) override;

    ~heat3dRefine() = default;
};

/**
 * @brief constructor
 * @param octDA
 * @param treePart tree partition
 * @param domainExtents domain information
 * @param inputData input data
 * @param subDomainBoundary boundary information (generateBoundaryFlags)
 */
heat3dRefine::heat3dRefine(DA *octDA,
                       const std::vector<TREENODE> &treePart,
                       const DomainExtents &domainExtents,
                       heat3dInputData *inputData,
                       SubDomainBoundary *subDomainBoundary)
    : Refinement(octDA, treePart, domainExtents), inputData_(inputData), domainExtents_(domainExtents), subDomainBoundary_(subDomainBoundary)
{
    this->traverse();
}
heat3dRefine::heat3dRefine(DA *octDA,
                       const std::vector<TREENODE> &treePart,
                       const DomainExtents &domainExtents,
                       heat3dInputData *inputData,
                       SubDomainBoundary *subDomainBoundary,
                       std::vector<GEOMETRY::Geometry *> ibmGeoms,
                       bool doCoarsen)
    : Refinement(octDA, treePart, domainExtents), inputData_(inputData), domainExtents_(domainExtents),
      subDomainBoundary_(subDomainBoundary), ibmGeoms_(std::move(ibmGeoms)), doCoarsen_(doCoarsen)
{
    this->traverse();
}

/**
 * @brief The refinement flags per element by element. If nothing is returned, its set to NO_CHANGE.
 * @param fe the element
 * @param coords vector of coords
 * @return the flags for each elements
 */
ot::OCT_FLAGS::Refine heat3dRefine::getRefineFlags(TALYFEMLIB::FEMElm &fe, const std::vector<TALYFEMLIB::ZEROPTV> &coords){
    const DomainInfo &physDomain = domainExtents_.physicalDADomain;
    const unsigned int nodeNo = m_octDA->getNumNodesPerElement();
    const DENDRITE_UINT currentLevel = this->m_level;

    /// refine walls (maximum to the refine_h level)
    const double eps = 1e-13;
    unsigned int levelForWall = inputData_->meshDef.refineLevel_base;
    const auto &refine_wall = inputData_->meshDef.refine_walls;
    if (inputData_->meshDef.refine_any_wall){
        if (refine_wall[0]){
            for (const auto &p : coords){
                if (p.x() - inputData_->meshDef.physDomain.min[0] < eps && currentLevel < inputData_->meshDef.refineLevel_channel_wall){
                    levelForWall = inputData_->meshDef.refineLevel_channel_wall;
                    break;
                }
            }
        }
        if (refine_wall[1]){
            for (const auto &p : coords){
                if (inputData_->meshDef.physDomain.max[0] - p.x() < eps && currentLevel < inputData_->meshDef.refineLevel_channel_wall){
                    levelForWall = inputData_->meshDef.refineLevel_channel_wall;
                    break;
                }
            }
        }
        if (refine_wall[2]){
            for (const auto &p : coords){
                if (p.y() - inputData_->meshDef.physDomain.min[1] < eps && currentLevel < inputData_->meshDef.refineLevel_channel_wall){
                    levelForWall = inputData_->meshDef.refineLevel_channel_wall;
                    break;
                }
            }
        }
        if (refine_wall[3]){
            for (const auto &p : coords){
                if (inputData_->meshDef.physDomain.max[1] - p.y() < eps && currentLevel < inputData_->meshDef.refineLevel_channel_wall){
                    levelForWall = inputData_->meshDef.refineLevel_channel_wall;
                    break;
                }
            }
        }
#if (DIM == 3)
        if (refine_wall[4]){
            for (const auto &p : coords){
                if (p.z() - inputData_->meshDef.physDomain.min[2] < eps && currentLevel < inputData_->meshDef.refineLevel_channel_wall){
                    levelForWall = inputData_->meshDef.refineLevel_channel_wall;
                    break;
                }
            }
        }
        if (refine_wall[5]){
            for (const auto &p : coords){
                if (inputData_->meshDef.physDomain.max[2] - p.z() < eps && currentLevel < inputData_->meshDef.refineLevel_channel_wall){
                    levelForWall = inputData_->meshDef.refineLevel_channel_wall;
                    break;
                }
            }
        }
#endif
    }

    /// region refine
    unsigned int maxlevelForRegion = inputData_->meshDef.refineLevel_base;
    if(inputData_->region_refine.size() > 0){
        auto &rf = inputData_->region_refine;
        std::vector<unsigned int> levelForRegions;
        levelForRegions.resize(rf.size());
        for (int i = 0; i < rf.size(); i++) {
            auto &r = rf[i];
            if (!r.forRetain) {
                for (const auto &p : coords){
                    if (r.in_region(p)){
                        levelForRegions[i] = r.refine_region_lvl;
                        break;
                    }else{
                        levelForRegions[i] = inputData_->meshDef.refineLevel_base;
                    }
                }
            }
        }
        if (!levelForRegions.empty()) {
            maxlevelForRegion = *max_element(levelForRegions.begin(), levelForRegions.end());
        }
        // for region with geometry, refine the boundries.
        std::vector<unsigned int> levelForRegionsGeomBoundary;
        std::vector<int> countOfInPointsEachRegionGeom;
        levelForRegionsGeomBoundary.resize(rf.size());
        countOfInPointsEachRegionGeom.resize(rf.size());
        for (unsigned int i = 0; i < rf.size(); i++) {
            auto &r = rf[i];
            if (!r.forRetain && r.GetRefineType() == RegionalRefine::MESHOBJECT){
                for (const auto &p : coords){
                    if (r.in_region(p)){
                        countOfInPointsEachRegionGeom[i]++;
                    }
                }
            }
        }
        for (unsigned int i = 0; i < rf.size(); i++) {
            if (not(countOfInPointsEachRegionGeom[i] == nodeNo || countOfInPointsEachRegionGeom[i] == 0)) {
                levelForRegionsGeomBoundary[i] = (rf[i].refine_region_lvl_boundary);
            }
        }
        levelForRegionsGeomBoundary.push_back(maxlevelForRegion);
        if (!levelForRegionsGeomBoundary.empty()){
            maxlevelForRegion = *max_element(levelForRegionsGeomBoundary.begin(), levelForRegionsGeomBoundary.end());
        }
        
        /// region retain (for complete outside elements outside retain region, we don't want to refine those)
        bool outsideRetain = false;
        for (auto &r : rf){
            if (r.forRetain) {
                bool all_out = true;
                for (const auto &p : coords){
                    all_out = all_out && (r.out_retain(p) == RegionalRefine::OUTSIDE);
                }
                outsideRetain = outsideRetain || all_out;
            }
        }
    }

    DENDRITE_UINT id = -1;
    bool isObject = false;
    if (this->m_BoundaryOctant) {
        for (DENDRITE_UINT i = 0; i < m_octDA->getNumNodesPerElement(); i++) {
            subDomainBoundary_->generateBoundaryFlags(coords[i], id);
            if (subDomainBoundary_->checkBoundaryType(BoundaryTypes::VOXEL::GEOMETRY) or
                subDomainBoundary_->checkBoundaryType(BoundaryTypes::VOXEL::SPHERE) or
                subDomainBoundary_->checkBoundaryType(BoundaryTypes::VOXEL::BOX) or
                subDomainBoundary_->checkBoundaryType(BoundaryTypes::VOXEL::CIRCLE))
            {
                isObject = true;
                break;
            }
        }
    }
    unsigned int maxlevelForCarvedOutGeom = inputData_->meshDef.refineLevel_base;
    if (isObject) {
        maxlevelForCarvedOutGeom = std::max(inputData_->carved_out_geoms_def.at(id).refineLevel, maxlevelForCarvedOutGeom);
    }

    unsigned int maxlevelForGeom = inputData_->meshDef.refineLevel_base;
    
    // refine based on custom criteria /////////////////////////////////////////////////////
    unsigned int customCriteriaLevel = inputData_->meshDef.refineLevel_base;

// No refinement criteria specified

    
    ////////////////////////////////////////////////////////////////////////////////////////
    
    //  if (outsideRetain) {
    //    levelForWall = inputData_->meshDef.refine_l;
    //  }
    if (!doCoarsen_){
        if (currentLevel < maxlevelForGeom or
            currentLevel < maxlevelForRegion or
            currentLevel < levelForWall or
            currentLevel < maxlevelForCarvedOutGeom or
            currentLevel < customCriteriaLevel) {
            return ot::OCT_FLAGS::Refine::OCT_REFINE;
        }else{
            return ot::OCT_FLAGS::Refine::OCT_NO_CHANGE;
        }
    }else{
        if (currentLevel > maxlevelForGeom and
            currentLevel > maxlevelForRegion and
            currentLevel > levelForWall and
            currentLevel > maxlevelForCarvedOutGeom and
            currentLevel > customCriteriaLevel)
        {
            return ot::OCT_FLAGS::Refine::OCT_COARSEN;
        }
    }

    return ot::OCT_FLAGS::Refine::OCT_NO_CHANGE;
}


