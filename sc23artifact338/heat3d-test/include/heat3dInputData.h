//This file was generated by Finch.

/*

*/
#pragma once

#include "heat3dInputDataStructs.h"
#include <time.h>

class heat3dInputData : public TALYFEMLIB::InputData{
public:
    static constexpr int nsd = DIM;

    bool Penalty = false;
    bool Special = false;
    bool Unsymmetric = false;
    bool InsideSBM = false;
    bool PenaltyNoShift = false;
    bool IfAdjointConsistency = true;
    bool IfNegativeAdjointConsistency = false;
    bool NormTheSame = false;

    bool PrintTrueSurfaceGP = false;
    bool PrintTrueSurfaceNP = false;
    bool SecondOrderTaylorQBF = true;
    bool SuperConvergencePt = false;
    bool HessianInNeumann = true;

    /// for SBM dist function calculation
    TALYFEMLIB::ZEROPTV PBoxStart;
    TALYFEMLIB::ZEROPTV PBoxEnd;
    std::vector<std::vector<ZEROPTV>> DistributePoints;
    std::vector<std::vector<int>> TriangleNumber;
    std::vector<ZEROPTV> GPPTVAll;
    
    int MaxLeaf = 10;

    /// solver (STABILIZED) and Variational multiscale based solver (RBVMS)
    enum typeSolver{
        STABILIZED = 0,
        RBVMS = 1
    };
    
    enum typeNondimension{
        FREECONV = 0,
        MIXCONV = 1
    };
    
    enum FalseInterceptedElementCheckType{
        VOLUME_CHECK = 0,
        DISTANCE_CHECK = 1
    };

    enum typeDistCalc{
        NORMAL_BASED = 0,
        NORMAL_BASED_DistributeSTL = 1,
        GP_BASED = 2,
        KD_TREE = 3
    };

    /// Declare the Solver type
    typeSolver solverType;
    
    /// Declare the dist calc type
    typeDistCalc DistCalcType = typeDistCalc::KD_TREE;
    
    /// Declare the way to check False Intercepted element
    FalseInterceptedElementCheckType falseInterceptedElementCheckType;

    DENDRITE_UINT elemOrder = 1;
    bool ifMatrixFree = false;

    /// Time stepper
    std::vector<double> dt;
    std::vector<double> totalT;
    std::vector<int> nSteps;
    double OutputStartTime;
    int OutputInterval;

    /// Postprocessing
    int PostProcessingInterval = 1;
    bool printToScreen = true;
    bool writeToFile = true;

    /// weakBC parameters
    double Cb_e = 200.0;
    double Cb_f = 20.0;
    double C_DC = 0.0;
    
    /// VMS parameters may be removed if not used
    double Ci_f = 36;
    double Ci_e = 36;
    double tauM_scale = 1.0;
    double tauM_scale4Side = 1.0;
    double tauM_time = 1.0;

    /// Timestepper control
    enum typeTimestepper{
        GENERALIZED_THETA = 0,
        BDF2 = 1
    };
    /// Declare the timestepper
    typeTimestepper timestepperType;
    double thetaTimeStepping = 1;      /// Default is backward Euler.
    double thetaTimeStepping4Side = 1; /// Default is backward Euler.

    /// tolerance for the block iterations
    double blockTolerance;
    /// maximum number of iterations for block iteration
    unsigned int iterMaxBlock;

    /// postprocessing (surface indicator to monitor)
    std::vector<unsigned int> SurfaceMonitor;

    std::vector<BoundaryDef> boundary_def;
    InitialConditionDef ic_def;

    /// Curved-out geometries
    std::vector<CarvedOutGeom> carved_out_geoms_def;

    /// Solver options for PETSc are handled in these structures
    SolverOptions solverOptions;

    /// Limiter
    Limiter limiter;

    /// Debug options
    bool Debug_Integrand = false;
    bool dump_vec = false;

    /// Setup the meshDef object for subDA parameters
    MeshDef meshDef;
    std::vector<RegionalRefine> region_refine;

    ~heat3dInputData() = default;

    bool ReadFromFile(const std::string &filename = std::string("config.txt")){
        ReadConfigFile(filename);
        ReadValue("elemOrder", elemOrder);
        ReadValue("matrixFree", ifMatrixFree);
        
        /// SubDA (channel parameters)
        meshDef.read_from_config(cfg.getRoot()["background_mesh"]);
        if (cfg.exists("region_refine")){
            const auto &cfg_refine = cfg.getRoot()["region_refine"];
            region_refine.resize(cfg_refine.getLength());
            for (unsigned int i = 0; i < region_refine.size(); i++){
                region_refine[i].read_from_config(cfg_refine[i]);
            }
        }

        /// timestep control
        ReadVectorOrValue("dt", dt);
        ReadVectorOrValue("totalT", totalT);
        ReadVectorOrValue("nSteps", nSteps);
        
        /// Output control
        if (ReadValue("OutputStartTime", OutputStartTime)){}
        if (ReadValue("OutputInterval", OutputInterval)){}

        //if (ReadValue("PostProcessingInterval", PostProcessingInterval)){}
        //if (ReadValue("printToScreen", printToScreen)){}
        //if (ReadValue("writeToFile", writeToFile)){}

        /// Solver selection
        /// Read type of solver
        solverType = read_solver(cfg.getRoot(), "solverType");
        
        /// Timestepper option
        timestepperType = read_Timestepper(cfg.getRoot(), "timeStepper");

        /// VMS parameters
        if (solverType == typeSolver::RBVMS){
            //if (ReadValue("Ci_f", Ci_f)){};
            //if (ReadValue("Ci_e", Ci_e)){};
            //if (ReadValue("tauM_scale", tauM_scale)){};
            //if (ReadValue("tauM_scale4Side", tauM_scale4Side)){};
            //if (ReadValue("tauM_time", tauM_time)){};
        }
    
        /// WeakBC parameters
        if (ReadValue("Cb_e", Cb_e)){};
        //if (ReadValue("Cb_f", Cb_f)){};
        //if (ReadValue("C_DC", C_DC)){};
        
        /// always have dim*2 boundary_def in the order of x-, x+, y-, y+, z-, z+
        boundary_def.resize(DIM * 2);
        boundary_def[0].side = BoundaryDef::Side::X_MINUS;
        boundary_def[1].side = BoundaryDef::Side::X_PLUS;
        boundary_def[2].side = BoundaryDef::Side::Y_MINUS;
        boundary_def[3].side = BoundaryDef::Side::Y_PLUS;
#if (DIM == 3)
        boundary_def[4].side = BoundaryDef::Side::Z_MINUS;
        boundary_def[5].side = BoundaryDef::Side::Z_PLUS;
#endif
        if (cfg.exists("boundary")){
          const auto &bc = cfg.getRoot()["boundary"];
          for (auto &bc_def : boundary_def){
            for (int j = 0; j < bc.getLength(); j++){
              /// If the side of bc in config matches with the preset bc
              if (bc_def.side == BoundaryDef::read_side_from_config(bc[j])){
                bc_def.read_from_config(bc[j]);
              }
            }
          }
        }
        
        /// read geometries
        if (cfg.exists("geometries")){
            const auto &geometries = cfg.getRoot()["geometries"];
            carved_out_geoms_def.resize(geometries.getLength());
            for (unsigned int i = 0; i < carved_out_geoms_def.size(); i++){
                carved_out_geoms_def[i].read_from_config(geometries[i]);
            }
        }

        /// Solver Options
        /// Simulation parameters and tolerances
        solverOptions = read_solver_options(cfg, "solver_options");

        /// Load surface postprocessing vector, or Nu calculation
        if (cfg.exists("SurfaceMonitor")){
            const libconfig::Setting &settings = cfg.getRoot()["SurfaceMonitor"];
            for (int i = 0; i < settings.getLength(); ++i){
                SurfaceMonitor.push_back(settings[i]);
            }
        }
        
        if (ReadValue("MaxLeaf", MaxLeaf)){};
        
        /// Read Checking way for False Intercepted Element
        std::string str;
        if (cfg.getRoot().lookupValue("FalseInterceptedElementCheckType", str)){
            if (str == "VOLUME_CHECK"){
                falseInterceptedElementCheckType = VOLUME_CHECK;
            }
            else if (str == "DISTANCE_CHECK"){
                falseInterceptedElementCheckType = DISTANCE_CHECK;
            }
            else{
                PrintStatus("Unexpected check for false intercepted elements. using default volume check");
                falseInterceptedElementCheckType = VOLUME_CHECK;
            }
        }else{
            PrintStatus("Default VOLUME_CHECK used for False Intercepted Element check");
            falseInterceptedElementCheckType = VOLUME_CHECK;
        }
        
        
        return true;
    }

    /// Function for reading a vector or a single value (stored in vector)
    template <typename T>
    void ReadVectorOrValue(const std::string &key_name, std::vector<T> &value){
        if (cfg.exists(key_name + "_V")){
            InputData::ReadVector(cfg, key_name + "_V", value);
        }else{
            double value_const;
            ReadValueRequired(key_name, value_const);
            value.push_back(value_const);
        }
    }
    
    bool CheckInputData(){
    	return true;
    }
    
    /**
    * Printout every item of inputdata for debug purpose.
    */
    void PrintInputData(){
        int rank = TALYFEMLIB::GetMPIRank();
        if (!rank){
            std::ofstream fout("InputDataOutput.txt", std::ios::app);
            time_t my_time = time(NULL);
            fout << "##############################"
                << "\n";
            fout << ctime(&my_time);
            fout << "Total number of processor = " << TALYFEMLIB::GetMPISize() << "\n";
            fout << "size of DendroInt " << sizeof(DendroIntL) << "\n";
            fout << "size of PetscInt " << sizeof(PetscInt) << "\n";

            fout << "Dimension: " << nsd << "\n";
            fout << "basisFunctionOrder: " << elemOrder << "\n";
            fout << "mfree: " << ifMatrixFree << "\n";
            if (solverType == typeSolver::STABILIZED){
                fout << "solverType: STABILIZED\n";
            }else{
                fout << "solverType: RBVMS\n";
            }

            fout << "====== meshDef ======"
                << "\n";
            meshDef.PrintMeshDef(fout);
            fout << "====================="
                << "\n\n";

            fout << "====== timestepper ======"
                << "\n";
            PrintVector(fout, "dt", dt);
            PrintVector(fout, "totalT", totalT);
            PrintVector(fout, "nSteps", nSteps);
            if (timestepperType == typeTimestepper::GENERALIZED_THETA){
                fout << "timestepperType: GENERALIZED_THETA\n";
            }else{
                fout << "timestepperType: BDF2\n";
            }
            fout << "thetaTimeStepping: " << thetaTimeStepping << "\n";
            fout << "thetaTimeStepping4Side: " << thetaTimeStepping4Side << "\n";
            fout << "====================="
                << "\n\n";

            fout << "===== parameters ======="
                << "\n";

            fout << "Cb_e: " << Cb_e << "\n";
            fout << "====================="
                << "\n\n";

            fout << "\nregion_refine: {\n";
            for (const auto &r : region_refine)
            {
                r.PrintRegionRefineDef(fout);
                fout << "}\n{\n";
            }
            fout << "=========== extra stuff =========="
                << "\n";
            // not very important
            fout << "OutputStartTime: " << OutputStartTime << "\n";
            fout << "OutputInterval: " << OutputInterval << "\n";
            fout << "PostProcessingInterval: " << PostProcessingInterval << "\n";
            fout << "printToScreen: " << printToScreen << "\n";
            fout << "writeToFile: " << writeToFile << "\n";
            PrintVector(fout, "SurfaceMonitor", SurfaceMonitor);
            fout << "========== solver settings ==========="
                << "\n";
            fout << "solverOptions: ["
                << "\n";
            for (auto &val : solverOptions.vals){
                fout << val.first << " --> " << val.second << "\n";
            }
            fout << "]"
                << "\n";
            fout.close();
            }
        //    /// Curved-out geometries
        //    std::vector<CarvedOutGeom> carved_out_geoms_def;
    }

private:
    /// Function for reading type of Heat equation solver
    static typeSolver read_solver(libconfig::Setting &root, const char *name){
        std::string str;
        /// If nothing specified stays stabilized
        if (root.lookupValue(name, str)){
            if (str == "stabilized"){
                return STABILIZED;
            }else if (str == "rbvms"){
                return RBVMS;
            }else{
                throw TALYFEMLIB::TALYException() << "Unknown solver name: " << name << str;
            }
        }else{
            throw TALYFEMLIB::TALYException() << "Must specify solverType: stabilized or rbvms";
        }
    }

    /// Function for reading type of timestepper
    static typeTimestepper read_Timestepper(libconfig::Setting &root, const char *name){
        std::string str = "GeneralizedTheta";
        /// If nothing specified stays Generalized theta
        if (root.lookupValue(name, str)){
            if (str == "GeneralizedTheta"){
                return GENERALIZED_THETA;
            }else if (str == "BDF2"){
                return BDF2;
            }else{
                throw TALYFEMLIB::TALYException() << "Unknown timestepper: " << name << str;
            }
        }else{
            return GENERALIZED_THETA;
        }
    }
};

