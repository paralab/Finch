//This file was generated by Finch.

/*

*/
#pragma once

#include "util.h"
#include <IMGA/IMGA.h>
#include "nanoflann.hpp"

using surface_kd_tree_t = nanoflann::KDTreeSingleIndexAdaptor<
    nanoflann::L2_Simple_Adaptor<double, PointCloud<double>>,
    PointCloud<double>, DIM>;

class SBMCalc{
private:
  double d[DIM];
  double DirichletBCValue;
  TALYFEMLIB::FEMElm fe_;
  const IMGA *imga_;
  const surface_kd_tree_t *kd_tree_;
  const heat3dInputData *idata_;
  ZEROPTV shift_;

  ZEROPTV normal;
  const double min_domain = 0.0;
  const double max_domain = 1.0 - min_domain;
  const double min_domain_RotBox = -0.5;
  const double max_domain_RotBox = 0.5;

  /**
    * @brief function to check whether the shited point on true boundary is within the corresponding triangle
    * @param pt the carved-out based gauss point position
    * @param d the distance function between true boundary and surrogate boundary
    * @param m_triangle the corresponding triangle to check whether the point is inside
    * @param shift the initial displacement of the stl geometry
    * @return [bool] whether the point is on the plane of the triangle
    */
  bool CheckInside3DTriangle(const ZEROPTV &pt, const double (&d)[DIM], const GEOMETRY::Triangles &m_triangle, const ZEROPTV &shift);

  /**
    * @brief calculate the shortest distance from octree-based Gauss Points to triangle edges
    * @param pt the carved-out based gauss point position
    * @param m_triangle the corresponding triangle to find the distance
    * @param shift the initial displacement of the stl geometry
    * @param d [out] the distance function from octree-based Gauss Points to triangle edges
    */
  void ShortestDist2TriEdge(const ZEROPTV &pt, const GEOMETRY::Triangles &m_triangle, const ZEROPTV &shift, double (&d)[DIM]);

public:
  /**
    * @brief constructor
    * @param fe the element we use to access gauss points
    * @param idata input Data
    * @param imga imga context, and we use this to access geometry
    */
  SBMCalc(const TALYFEMLIB::FEMElm &fe, const heat3dInputData *idata, const IMGA *imga);
  SBMCalc(const TALYFEMLIB::FEMElm &fe, const heat3dInputData *idata, const IMGA *imga, const surface_kd_tree_t *kd_tree);
  
  /**
    * @brief calculate the distance function for different kinds of geometries
    * @param d [out] distance function
    */
  void Dist2Geo(double (&d)[DIM]);

  /**
    * @brief calculate the true normal of the SBM geometry
    * @param normal true normal of SBM geometry
    * @param d distance function
    */
  void NormalofGeo(ZEROPTV &normal, const double (&d)[DIM]);

};

SBMCalc::SBMCalc(const TALYFEMLIB::FEMElm &fe, const heat3dInputData *idata, const IMGA *imga)
    : fe_(fe), imga_(imga), shift_(idata->carved_out_geoms_def[0].InitialDisplacement){
  idata_ = idata;
}

SBMCalc::SBMCalc(const TALYFEMLIB::FEMElm &fe, const heat3dInputData *idata, const IMGA *imga, const surface_kd_tree_t *kd_tree)
    : fe_(fe), imga_(imga), shift_(idata->carved_out_geoms_def[0].InitialDisplacement), kd_tree_(kd_tree){
    idata_ = idata;
}

bool SBMCalc::CheckInside3DTriangle(const ZEROPTV &pt, const double (&d)[DIM], const GEOMETRY::Triangles &m_triangle, const ZEROPTV &shift){
  const ZEROPTV ptMove{pt(0) + d[0] - shift(0), pt(1) + d[1] - shift(1), pt(2) + d[2] - shift(2)};

  const ZEROPTV ptA{m_triangle.triangleCoord[0][0], m_triangle.triangleCoord[0][1], m_triangle.triangleCoord[0][2]};
  const ZEROPTV ptB{m_triangle.triangleCoord[1][0], m_triangle.triangleCoord[1][1], m_triangle.triangleCoord[1][2]};
  const ZEROPTV ptC{m_triangle.triangleCoord[2][0], m_triangle.triangleCoord[2][1], m_triangle.triangleCoord[2][2]};

  ZEROPTV u;
  ZEROPTV v;
  ZEROPTV w;

  u.crossProduct(ptB - ptA, ptMove - ptA);
  v.crossProduct(ptC - ptB, ptMove - ptB);
  w.crossProduct(ptA - ptC, ptMove - ptC);

  if (u.innerProduct(v) < 0.0f){
    return false;
  }else if (u.innerProduct(w) < 0.0f){
    return false;
  }else {
    return true;
  }
}

void SBMCalc::ShortestDist2TriEdge(const ZEROPTV &pt, const GEOMETRY::Triangles &m_triangle, const ZEROPTV &shift, double (&d)[DIM]){
  std::vector<ZEROPTV> ShortestVector2Line(3);
  std::vector<ZEROPTV> ptri(3);
  for (int trinum = 0; trinum < DIM; trinum++){
    ptri[trinum] = {m_triangle.triangleCoord[trinum][0] + shift[0], m_triangle.triangleCoord[trinum][1] + shift[1], m_triangle.triangleCoord[trinum][2] + shift[2]};
  }

  ShortestVector2Line[0] = (ptri[1] - ptri[0]) * (((pt - ptri[0]).innerProduct(ptri[1] - ptri[0])) / (ptri[1] - ptri[0]).norm()) - (pt - ptri[0]);
  ShortestVector2Line[1] = (ptri[2] - ptri[1]) * (((pt - ptri[1]).innerProduct(ptri[2] - ptri[1])) / (ptri[2] - ptri[1]).norm()) - (pt - ptri[1]);
  ShortestVector2Line[2] = (ptri[0] - ptri[2]) * (((pt - ptri[2]).innerProduct(ptri[0] - ptri[2])) / (ptri[0] - ptri[2]).norm()) - (pt - ptri[2]);

  int pickNumber = 0;
  double mindist = 100;
  for (int trinum = 0; trinum < DIM; trinum++){
    if (ShortestVector2Line[trinum].norm() < mindist){
      pickNumber = trinum;
      mindist = ShortestVector2Line[trinum].norm();
    }
  }

  for (int trinum = 0; trinum < DIM; trinum++){
    d[trinum] = ShortestVector2Line[pickNumber](trinum);
  }
}

void SBMCalc::Dist2Geo(double (&d)[DIM]){
  const ZEROPTV pt = fe_.position();
  double x = pt.x();
  double y = pt.y();
  
  //////////////////////////////////////////////////////////////////////////////////////////////////
  // Set these if specifying the distance to geometry below
  bool user_specified_distance = false;
  bool general_mesh_distance = true;
  //////////////////////////////////////////////////////////////////////////////////////////////////

#if (DIM == 2)

  if(user_specified_distance){
    
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Put the mesh-specific distance to geometry code here.
    // This is a circle. This code needs to be specified by the user because it is specific to the mesh
    double radius = 1.0;
    double radius_gp = sqrt((x - shift_.x()) * (x - shift_.x()) + (y - shift_.y()) * (y - shift_.y()));
    d[0] = (radius * (x - shift_.x()) / radius_gp + shift_.x()) - x;
    d[1] = (radius * (y - shift_.y()) / radius_gp + shift_.y()) - y;
    //////////////////////////////////////////////////////////////////////////////////////////////
    
  }else if(general_mesh_distance){
    
    // This will attempt to work for an unknown mesh
    auto m_lines = imga_->getGeometries()[0]->getMSH()->getLines();
    int msh_size = m_lines.size();

    double MinDist = sqrt(2) * util_funcs::ElementSize(fe_);
    for (DENDRITE_UINT i = 0; i < msh_size; i++)
    {
      if (sqrt(pow(x - m_lines[i].lineCoord[0][0] - shift_[0],2) + pow(y - m_lines[i].lineCoord[0][1] - shift_[1],2)) < MinDist)
      {
        MinDist = sqrt(pow(x - m_lines[i].lineCoord[0][0] - shift_[0],2) + pow(y - m_lines[i].lineCoord[0][1] - shift_[1],2));
        d[0] = m_lines[i].lineCoord[0][0] + shift_[0] - x;
        d[1] = m_lines[i].lineCoord[0][1] + shift_[1] - y;
      }
    }
    
  }else{
    // returning zero distance
    d[0] = 0.0;
    d[1] = 0.0;
  }

#endif
#if (DIM == 3)

  double z = pt.z();

  if(user_specified_distance){
    
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Put the mesh-specific distance to geometry code here.
    // This is a sphere. This code needs to be specified by the user because it is specific to the mesh
    double radius = shift_[0]; // The center is at (radius,radius,radius)
    double radius_gp = sqrt((x - radius) * (x - radius) + (y - radius) * (y - radius) + (z - radius) * (z - radius));
    d[0] = (radius * (x - radius) / radius_gp + radius) - x;
    d[1] = (radius * (y - radius) / radius_gp + radius) - y;
    d[2] = (radius * (z - radius) / radius_gp + radius) - z;
    //////////////////////////////////////////////////////////////////////////////////////////////
    
  }else if(general_mesh_distance){
    // This will attempt to work for an unknown mesh
    double MinDist = 100.0;
    ZEROPTV OnePointVector;
    ZEROPTV PickNormalVector;
    int PickGeomID = 0;
    int PickTrianleID = 0;

    switch (idata_->DistCalcType){

    case heat3dInputData::typeDistCalc::GP_BASED:
    {
      for (const auto gp : idata_->GPPTVAll){
        if (sqrt(pow(x - gp(0), 2) + pow(y - gp(1), 2) + pow(z - gp(2), 2)) < MinDist){
          MinDist = sqrt(pow(x - gp(0), 2) + pow(y - gp(1), 2) + pow(z - gp(2), 2));
          d[0] = gp(0) - x;
          d[1] = gp(1) - y;
          d[2] = gp(2) - z;
        }
      }
      break;
    }

    case heat3dInputData::typeDistCalc::NORMAL_BASED_DistributeSTL:
    {
      for (int geoID = 0; geoID < imga_->getGeometries().size(); geoID++){
        std::vector<GEOMETRY::Triangles> m_triangles = imga_->getGeometries()[geoID]->getSTL()[0].getTriangles();

        assert(idata_->PBoxEnd(0) > x && idata_->PBoxEnd(1) > y && idata_->PBoxEnd(2) > z && idata_->PBoxStart(0) < x && idata_->PBoxStart(1) < y && idata_->PBoxStart(2) < z);
        int it = 0;
        for (auto point : idata_->DistributePoints[geoID]){
          if (sqrt(pow(x - point.x() - shift_[0], 2) + pow(y - point.y() - shift_[1], 2) + pow(z - point.z() - shift_[2], 2)) < MinDist){
            MinDist = sqrt(pow(x - point.x() - shift_[0], 2) + pow(y - point.y() - shift_[1], 2) + pow(z - point.z() - shift_[2], 2));
            for (int dim = 0; dim < DIM; dim++){
              OnePointVector(dim) = m_triangles[idata_->TriangleNumber[geoID][it]].triangleCoord[0][dim] + shift_[dim] - pt(dim);
              PickNormalVector(dim) = m_triangles[idata_->TriangleNumber[geoID][it]].normal[dim];
              PickTrianleID = idata_->TriangleNumber[geoID][it];
              PickGeomID = geoID;
            }
          }
          it++;
        }
      }

      // scaling of vector
      double scale = 0.0;
      for (int dim = 0; dim < DIM; dim++){
        scale += OnePointVector(dim) * PickNormalVector(dim);
      }

      for (int dim = 0; dim < DIM; dim++){
        d[dim] = scale * PickNormalVector(dim);
      }

      GEOMETRY::Triangles m_triangle = imga_->getGeometries()[PickGeomID]->getSTL()[0].getTriangles()[PickTrianleID];
      if (!CheckInside3DTriangle(pt, d, m_triangle, shift_)){
        ShortestDist2TriEdge(pt, m_triangle, shift_, d);
      }
      break;
    }

    case heat3dInputData::typeDistCalc::NORMAL_BASED:
    {
      for (int geoID = 0; geoID < imga_->getGeometries().size(); geoID++){
        std::vector<GEOMETRY::Triangles> m_triangles = imga_->getGeometries()[geoID]->getSTL()[0].getTriangles();
        //std::cout<<"m_triangles.size() = " << m_triangles.size() << "\n";

        for (int i = 0; i < m_triangles.size(); i++){
          // Check if the distance from center of mass(COM) is greater than extent of triangle.
          // Do for each dimension in sequence to minimize work
          double centerX = (m_triangles[i].triangleCoord[0][0] + m_triangles[i].triangleCoord[1][0] + m_triangles[i].triangleCoord[2][0]) / 3 - shift_[0];
          double extent = std::max(fabs(m_triangles[i].triangleCoord[0][0] - m_triangles[i].triangleCoord[1][0]), 
                                    std::max(fabs(m_triangles[i].triangleCoord[2][0] - m_triangles[i].triangleCoord[1][0]), 
                                            fabs(m_triangles[i].triangleCoord[2][0] - m_triangles[i].triangleCoord[0][0])));
          double displacementX = x - centerX;
          if(fabs(x - centerX) < extent){
            double centerY = (m_triangles[i].triangleCoord[0][1] + m_triangles[i].triangleCoord[1][1] + m_triangles[i].triangleCoord[2][1]) / 3 - shift_[1];
            extent = std::max(fabs(m_triangles[i].triangleCoord[0][1] - m_triangles[i].triangleCoord[1][1]), 
                              std::max(fabs(m_triangles[i].triangleCoord[2][1] - m_triangles[i].triangleCoord[1][1]), 
                                      fabs(m_triangles[i].triangleCoord[2][1] - m_triangles[i].triangleCoord[0][1])));
            double displacementY = y - centerY;
            
            if(fabs(displacementY) < extent){
              double centerZ = (m_triangles[i].triangleCoord[0][2] + m_triangles[i].triangleCoord[1][2] + m_triangles[i].triangleCoord[2][2]) / 3 - shift_[2];
              extent = std::max(fabs(m_triangles[i].triangleCoord[0][2] - m_triangles[i].triangleCoord[1][2]), 
                                std::max(fabs(m_triangles[i].triangleCoord[2][2] - m_triangles[i].triangleCoord[1][2]), 
                                        fabs(m_triangles[i].triangleCoord[2][2] - m_triangles[i].triangleCoord[0][2])));
              double displacementZ = z - centerZ;
              if(fabs(displacementZ) < extent){
                double tmp_dist = displacementX*displacementX + displacementY*displacementY + displacementZ*displacementZ;
                if (tmp_dist < MinDist){
                  MinDist = tmp_dist;
                  
                  for (int dim = 0; dim < DIM; dim++){
                    OnePointVector(dim) = m_triangles[i].triangleCoord[0][dim] + shift_[dim] - pt(dim);
                    PickNormalVector(dim) = m_triangles[i].normal[dim];
                    PickTrianleID = i;
                    PickGeomID = geoID;
                  }
                }
              }
            }
          }
        }
      }

      // scaling of vector
      double scale = 0.0;
      for (int dim = 0; dim < DIM; dim++){
        scale += OnePointVector(dim) * PickNormalVector(dim);
      }

      for (int dim = 0; dim < DIM; dim++){
        d[dim] = scale * PickNormalVector(dim);
      }

      GEOMETRY::Triangles m_triangle = imga_->getGeometries()[PickGeomID]->getSTL()[0].getTriangles()[PickTrianleID];
      if (!CheckInside3DTriangle(pt, d, m_triangle, shift_)){
        ShortestDist2TriEdge(pt, m_triangle, shift_, d);
      }
      break;
    }
    case heat3dInputData::typeDistCalc::KD_TREE:
    {
        size_t num_results = 1;
        std::vector<uint32_t> ret_index(num_results);
        std::vector<double> out_dist_sqr(num_results);

        const double query_pt[3] = {x - shift_[0], y - shift_[1], z - shift_[2]}; // shift_

        num_results = kd_tree_->knnSearch(
            &query_pt[0], num_results, &ret_index[0], &out_dist_sqr[0]);

        for (int geoID = 0; geoID < imga_->getGeometries().size(); geoID++){
            const std::vector<GEOMETRY::Triangles> *m_triangles = &imga_->getGeometries()[geoID]->getSTL()[0].getTriangles();
            for (int dim = 0; dim < DIM; dim++){
                OnePointVector(dim) = m_triangles->at(ret_index[0]).triangleCoord[0][dim] + shift_[dim] - pt(dim);
                PickNormalVector(dim) = m_triangles->at(ret_index[0]).normal[dim];
            }
            PickTrianleID = ret_index[0];
            PickGeomID = geoID;
        }

        // scaling of vector
        double scale = 0.0;
        for (int dim = 0; dim < DIM; dim++){
            scale += OnePointVector(dim) * PickNormalVector(dim);
        }

        for (int dim = 0; dim < DIM; dim++){
            d[dim] = scale * PickNormalVector(dim);
        }

        GEOMETRY::Triangles m_triangle = imga_->getGeometries()[PickGeomID]->getSTL()[0].getTriangles()[PickTrianleID];
        if (!CheckInside3DTriangle(pt, d, m_triangle, shift_)){
            ShortestDist2TriEdge(pt, m_triangle, shift_, d);
        }
        break;
    }
    }
    
  }else{
    // returning zero distance
    d[0] = 0.0;
    d[1] = 0.0;
    d[2] = 0.0;
  }
#endif
}

void SBMCalc::NormalofGeo(ZEROPTV &normal, const double (&d)[DIM]){
  double R2 = 0;

  for (int dim = 0; dim < DIM; dim++){
    R2 += pow(d[dim], 2);
  }
  for (int dim = 0; dim < DIM; dim++){
    normal(dim) = -d[dim] / sqrt(R2);
  }
}


