//This file was generated by Finch.

/*

*/
#pragma once
#include "heat3dNodeData.h"
#include "heat3dRefine.h"
#include "heat3dInputData.h"

#include <iostream>
#include <DendriteUtils.h>
#include <point.h>
#include <TalyEquation.h>
#include <PETSc/Solver/LinearSolver.h>
#include <PETSc/PetscUtils.h>
#include <IO/VTU.h>
#include <Traversal/Analytic.h>
#include <PETSc/IO/petscVTU.h>
#include <SubDA/SubDomain.h>
#include <Boundary/SubDomainBoundary.h>
#include <Checkpoint/Checkpointer.h>
#include <talyfem/input_data/input_data.h>
#include <talyfem/talyfem.h>
#include <DataTypes.h>
#include <point.h>
#include <DendriteUtils.h>
#include <map>
#include <vector>
#include <string>
#include <PETSc/VecBounds.h>

// #include "BFS.h"
// #include "ElementMarker.h"
// #include "ElementMarkerSurfaceLoop.h"

namespace util_funcs{
    
    void GetLineEdgePt(const std::vector<GEOMETRY::MSH *> &mshs,PointCloud<double> &CenterPts){

        for (int mshID = 0; mshID < mshs.size(); mshID++){
            const std::vector<GEOMETRY::Lines> *m_lines = &mshs[mshID]->getLines();

            CenterPts.pts.resize(m_lines->size());

            for (int i = 0;i<m_lines->size();i++){
                CenterPts.pts[i].x = m_lines->at(i).lineCoord[0][0];
                CenterPts.pts[i].y = m_lines->at(i).lineCoord[0][1];
                CenterPts.pts[i].z = 0;
            }
        }
    }

    void GetTriangleCenter(const std::vector<GEOMETRY::STL *> &stls,PointCloud<double> &CenterPts){
        for (int stlID = 0; stlID < stls.size(); stlID++){
            const std::vector<GEOMETRY::Triangles> *m_triangles = &stls[stlID]->getTriangles();
            //std::cout<<"m_triangles.size() = " << m_triangles.size() << "\n";
            CenterPts.pts.resize(m_triangles->size());
            for (int i = 0;i<m_triangles->size();i++){
                CenterPts.pts[i].x =(m_triangles->at(i).triangleCoord[0][0] + m_triangles->at(i).triangleCoord[1][0] + m_triangles->at(i).triangleCoord[2][0]) / 3;
                CenterPts.pts[i].y =(m_triangles->at(i).triangleCoord[0][1] + m_triangles->at(i).triangleCoord[1][1] + m_triangles->at(i).triangleCoord[2][1]) / 3;
                CenterPts.pts[i].z =(m_triangles->at(i).triangleCoord[0][2] + m_triangles->at(i).triangleCoord[1][2] + m_triangles->at(i).triangleCoord[2][2]) / 3;
            }
        }
    }


    // This is only used by print2vtk
    void sortrows(std::vector<std::vector<double>>& matrix, int col) {
        std::sort(matrix.begin(), matrix.end(),
                    [col](const std::vector<double>& lhs, const std::vector<double>& rhs) {
                        return lhs[col] > rhs[col];
                    });
    }
    
    void UniquePtvVector(const std::vector<ZEROPTV> &PTV, std::vector<ZEROPTV> &PTVnew){
        for (int i=0;i<PTV.size();i++){
            int count =0;
            for (int j=0;j<PTVnew.size();j++) {
                if (fabs(PTV[i].distanceTo(PTVnew[j])) >1e-15){
                    count++;
                }
            }

            if (count== PTVnew.size()){
                PTVnew.push_back(PTV[i]);
            }
        }
    }

  void print2vtk(const std::string &fPrefix, std::vector<ZEROPTV> PTV, const ZEROPTV &center){
      std::vector<ZEROPTV> PTVtemp;
      std::vector<ZEROPTV> PTVnew;
      std::vector<ZEROPTV> PTVnew2;

      if (TALYFEMLIB::GetMPIRank() == 0){ // if:master cpu, then:print
          ZEROPTV ptv1,ptv2;
          std::vector<std::vector<double>> AngleMap;

          PTVtemp.resize(PTV.size());
          PTVnew.resize(PTV.size());

          AngleMap.resize(PTV.size());
          for (int i =0; i<PTV.size();i+=2){

              AngleMap[i].resize(2);
              AngleMap[i+1].resize(2);

              for (int dim=0;dim<DIM;dim++){
                  if (PTV[i](dim) == PTV[i+1](dim)){
                      if (dim == 0){
                          ptv1 = {PTV[i](0),(PTV[i](1)+PTV[i+1](1))/2 + sqrt(3)*(PTV[i+1](1)-(PTV[i](1)+PTV[i+1](1))/2),0};
                          ptv2 = {PTV[i](0),(PTV[i](1)+PTV[i+1](1))/2 - sqrt(3)*(PTV[i+1](1)-(PTV[i](1)+PTV[i+1](1))/2),0};
                      } else if (dim == 1){
                          ptv1 = {(PTV[i](0)+PTV[i+1](0))/2 + sqrt(3)*(PTV[i+1](0)-(PTV[i](0)+PTV[i+1](0))/2),PTV[i](1),0};
                          ptv2 = {(PTV[i](0)+PTV[i+1](0))/2 - sqrt(3)*(PTV[i+1](0)-(PTV[i](0)+PTV[i+1](0))/2),PTV[i](1),0};
                      }
                      PTVtemp[i] = ptv1;
                      PTVtemp[i+1] = ptv2;
                      AngleMap[i][0] = i;
                      AngleMap[i][1] = atan2(PTVtemp[i].y()-center.y(),PTVtemp[i].x()-center.x());
                      AngleMap[i+1][0] = i+1;
                      AngleMap[i+1][1] = atan2(PTVtemp[i+1].y()-center.y(),PTVtemp[i+1].x()-center.x());
                  }
              }
          }

          sortrows(AngleMap,1);

          for (int i =0; i < PTVtemp.size();i++){
              PTVnew[i] = PTVtemp[AngleMap[i][0]];
          }
          
          UniquePtvVector(PTVnew,PTVnew2);
            
            int counter = 0;
            for (int dim =0;dim<DIM;dim++) {
                if (fabs(PTVnew2[PTVnew2.size()-1](dim)-PTVnew2[0](dim)) < 1e-12){
                    counter++;
                }
            }
            if (counter ==0){
                ZEROPTV ptvTemp = PTVnew2[1];
                PTVnew2[1] = PTVnew2[0];
                PTVnew2[0] = ptvTemp;
            }

            for (int i =0;i<PTVnew2.size()-1;i++){
                int counter = 0;
                for (int dim =0;dim<DIM;dim++) {
                    if (fabs(PTVnew2[i](dim)-PTVnew2[i + 1](dim)) < 1e-12){
                        counter++;
                    }
                }
                if (counter ==0){
                    ZEROPTV ptvTemp = PTVnew2[i+1];
                    PTVnew2[i+1] = PTVnew2[i+2];
                    PTVnew2[i+2] = ptvTemp;
                }
            }
            
            char fname[256];
            snprintf(fname, sizeof(fname), "%s.vtk", fPrefix.c_str());
            std::ofstream fout(fname);

            int NGP = PTVnew2.size();

            fout << "# vtk DataFile Version 2.0\n";
            fout << "Created by Dendrite-KT\n";
            fout << "ASCII\n";
            fout << "DATASET UNSTRUCTURED_GRID\n";
            fout << "POINTS " << NGP << " double\n";

            for (int i = 0; i < NGP; i++){
                fout << PTVnew2[i].x() << " " << PTVnew2[i].y() << " 0"
                     << "\n";
            }
            fout << "\n";

            fout << "CELLS " << NGP << " " << NGP * 3 << "\n";
            for (int k = 0; k < NGP; k++) {
                if (k + 1 >= NGP){
                    fout << "2 " << k << " " << k + 1 - NGP << "\n";
                }else{
                    fout << "2 " << k << " " << k + 1 << "\n";
                }
            }
            fout << "\n";
            fout << "CELL_TYPES " << NGP << "\n";
            int k = 0;
            for (int i = 0; i < NGP; i++){
                fout << "3\n";
            }
            fout.close();
      }
  }
  
  // void generateNeighborsOfFalseIntercepted(DA *& octDA, DistTREE & distTree, DomainExtents & domainExtents, SubDomain & subDomain,
  //                                            std::vector<std::bitset<ElementMarker::MAX_ELMENT_TYPE>> & elementMarker,
  //                                            Vec & nodalFalseElement, heat3dInputData *idata,SubDomainBoundary *subDomainBoundary,const IMGA *imga
  //                                            ,  bool isAllocated = false){
  //       using CoordT = typename ot::DA<DIM>::C;
  //       using ot::RankI;
  //       OctToPhysical octToPhysical(domainExtents);
  //       const DENDRITE_UINT nPe = octDA->getNumNodesPerElement();
  //       const auto &treeNodes = distTree.getTreePartFiltered();
  //       std::vector<PetscInt> nodeIDs(treeNodes.size() * nPe, -1);

  //       // Get Global element ID
  //       {
  //           const std::vector<RankI> &ghostedGlobalNodeId = octDA->getNodeLocalToGlobalMap();
  //           const size_t ghostedNodalSz = octDA->getTotalNodalSz();
  //           const TREENODE *odaCoords = octDA->getTNCoords();
  //           const bool visitEmpty = false;
  //           const unsigned int padLevel = 0;
  //           ot::MatvecBaseIn<DIM, RankI, false> treeLoopIn(ghostedNodalSz,
  //                                                          1,                // node id is scalar
  //                                                          octDA->getElementOrder(),
  //                                                          visitEmpty,
  //                                                          padLevel,
  //                                                          odaCoords,
  //                                                          &(*ghostedGlobalNodeId.cbegin()),
  //                                                          &(*treeNodes.cbegin()),
  //                                                          treeNodes.size(),
  //                                                          *octDA->getTreePartFront(),
  //                                                          *octDA->getTreePartBack());

  //           int eleCounter = 0;
  //           while (!treeLoopIn.isFinished()) {
  //               const ot::TreeNode<CoordT, DIM> subtree = treeLoopIn.getCurrentSubtree();
  //               const auto subtreeInfo = treeLoopIn.subtreeInfo();
  //               if (treeLoopIn.isPre() && subtreeInfo.isLeaf()) {
  //                   const RankI *nodeIdsFlat = subtreeInfo.readNodeValsIn();
  //                   const auto &octCoords = subtreeInfo.getNodeCoords();
  //                   const std::vector<bool> &nodeNonhangingIn = subtreeInfo.readNodeNonhangingIn();
  //                   for (int i = 0; i < nPe; i++) {
  //                       //if (nodeNonhangingIn[i]) {
  //                       nodeIDs[eleCounter * nPe + i] = nodeIdsFlat[i];
  //                       //}
  //                   }
  //                   eleCounter++;
  //               }
  //               treeLoopIn.step();
  //           }
  //       }
  //       // Get Global node ID ends

  //       // Transfer cell information to nodes
  //       if(!isAllocated) {
  //           octDA->petscCreateVector(nodalFalseElement, false, false, 1);
  //       }
  //       VecSet(nodalFalseElement,0);
  //       for(int i = 0; i < treeNodes.size();i++){
  //           if(elementMarker[i].test(ElementMarker::SBM_FALSE_INTERCEPTED)){
  //               for(int n = 0; n < nPe; n++){
  //                   VecSetValue(nodalFalseElement,nodeIDs[nPe*i + n],NodeMarker::SBM_FALSE_INTERCEPTED_NODES,INSERT_VALUES);
  //               }
  //           }
  //       }
  //       VecAssemblyBegin(nodalFalseElement);
  //       VecAssemblyEnd(nodalFalseElement);
  //       // Transfer ends

  //       // Do one iteration of BFS to find the neighbors of false intercepted
  //       {
  //           BFS bfs(octDA, distTree.getTreePartFiltered(), elementMarker,domainExtents,VecInfo(nodalFalseElement, 1, 0), &subDomain,idata,
  //                   subDomainBoundary, imga);

  //           std::vector<double> printMarker(elementMarker.size());
  //           for(int i = 0; i < elementMarker.size();i++){
  //               printMarker[i] = (double )(elementMarker[i].to_ulong());
  //           }
  //           const char *varname[] = {"marker"};
  //           IO::writeVecTopVtu(octDA,distTree.getTreePartFiltered(),printMarker.data(),"MarkerNeighbors","marker",varname,domainExtents,true);

  //       }
  //   }

    // void generateNewMarkers(DA * octDA, DistTREE & distTree, DomainExtents & domainExtents, SubDomain & subDomain,
    //                         SubDomainBoundary *subDomainBoundary,const IMGA *imga,
    //                         std::vector<std::bitset<ElementMarker::MAX_ELMENT_TYPE>> & elementMarker,
    //                         std::vector<std::bitset<ElementMarker::MAX_ELMENT_TYPE>> & elementMarkerVisualize,
    //                         Vec &nodalFalseElement , heat3dInputData *idata){
    //     int RelativeOrder = idata->RelOrderCheckActive;

    //     if (idata->falseInterceptedElementCheckType == heat3dInputData::FalseInterceptedElementCheckType::VOLUME_CHECK) {

    //         SBMMarker marker(octDA, distTree.getTreePartFiltered(), domainExtents, elementMarker, &subDomain,
    //                          RelativeOrder, idata);
    //         //marker.WriteDomainGPToFile();

    //     } else if (idata->falseInterceptedElementCheckType == heat3dInputData::FalseInterceptedElementCheckType::DISTANCE_CHECK) {
    //         ElementMarkerSurfaceLoop elementMarkerSurfaceLoop(octDA, distTree.getTreePartFiltered(), domainExtents,
    //                                                           &subDomain, subDomainBoundary, idata, imga,
    //                                                           elementMarker);
    //         //elementMarkerSurfaceLoop.WriteSurrfaceCheckPointToFile();
    //     }
    //     elementMarkerVisualize = elementMarker;
            
    //     //octDA->petscCreateVector(nodalFalseElement, false, false, heat3dNodeData::HT_DOF);
    //     // generateNeighborsOfFalseIntercepted(octDA, distTree, domainExtents,  subDomain,elementMarker,nodalFalseElement,idata, subDomainBoundary, imga,
    //     //                                    true);
    //     // generateNeighborsOfFalseIntercepted(octDA, distTree, domainExtents,  subDomain,elementMarker,nodalFalseElement,idata, subDomainBoundary, imga,
    //     //                                     false);

    //     //const char *varname[] = {"marker"};
    //     //PETSc::petscVectopvtu(octDA,distTree.getTreePartFiltered(),nodalFalseElement,"MarkerNeighbors","Nodes",varname,domainExtents,
    //     //                      false);

    // }

  DENDRITE_REAL ElementSize(const TALYFEMLIB::FEMElm &fe){
    return pow((pow(2, DIM) * fe.jacc()), (double)1 / DIM);
  }

  void TranslateGaussPoints(const std::vector<NodeAndValues<DENDRITE_REAL>> &gaussPoints, const std::vector<ZEROPTV> translations,
                            std::vector<ZEROPTV> &GPMove){
    GPMove.resize(gaussPoints.size());
    int counter = -1;
    for (const auto &gp : gaussPoints){
      counter++;
      for (int dim = 0; dim < DIM; dim++){
        GPMove[counter](dim) = gp.location[dim] + translations[counter](dim);
#if (DIM == 2)
        GPMove[counter](2) = 0;
#endif
      }
    }
  }

  void CalVec(double A, double B, double C, double x1, double y1, double &d1, double &d2){
    d1 = -A * (A * x1 + B * y1 + C) / (A * A + B * B);
    d2 = -B * (A * x1 + B * y1 + C) / (A * A + B * B);
  }

  void CalDist(double A, double B, double C, double x1, double y1, double &d){
    d = fabs(A * x1 + B * y1 + C) / sqrt(A * A + B * B);
  }

  static DENDRITE_REAL computeTriangleArea(const DENDRITE_REAL triCoords[][3]){
    /// calculate the normal and size of the surface
    TALYFEMLIB::ZEROPTV pts_0{triCoords[0][0], triCoords[0][1], triCoords[0][2]};
    TALYFEMLIB::ZEROPTV pts_1{triCoords[1][0], triCoords[1][1], triCoords[1][2]};
    TALYFEMLIB::ZEROPTV pts_2{triCoords[2][0], triCoords[2][1], triCoords[2][2]};
    TALYFEMLIB::ZEROPTV side_1, side_2;
    for (int dim = 0; dim < DIM; dim++){
      side_1(dim) = pts_1(dim) - pts_0(dim);
      side_2(dim) = pts_2(dim) - pts_0(dim);
    }

    /// this normal is either outside or inside, need to be pointed inside afterwards
    TALYFEMLIB::ZEROPTV normal;
    normal.crossProduct(side_1, side_2);
    const DENDRITE_REAL area = 0.5 * normal.SafeNormalize(); /// note: this line also normalizes normal!
    return area;
  }

  static DENDRITE_REAL computeSumTriangleArea(const ZEROPTV pt, const DENDRITE_REAL triCoords[][3]){
    /// calculate the normal and size of the surface
    std::vector<TALYFEMLIB::ZEROPTV> pts(3);
    pts[0] = {triCoords[0][0], triCoords[0][1], triCoords[0][2]};
    pts[1] = {triCoords[1][0], triCoords[1][1], triCoords[1][2]};
    pts[2] = {triCoords[2][0], triCoords[2][1], triCoords[2][2]};

    DENDRITE_REAL area = 0;

    for (int dim = 0; dim < DIM; dim++){
      pts[dim] = pt;
      TALYFEMLIB::ZEROPTV side_1, side_2;
      for (int dim = 0; dim < DIM; dim++){
        side_1(dim) = pts[1](dim) - pts[0](dim);
        side_2(dim) = pts[2](dim) - pts[0](dim);
      }

      /// this normal is either outside or inside, need to be pointed inside afterwards
      TALYFEMLIB::ZEROPTV normal;
      normal.crossProduct(side_1, side_2);
      area += 0.5 * normal.SafeNormalize(); /// note: this line also normalizes normal!
    }
    return area;
  }

  void PrintTriangleInfo(const std::vector<GEOMETRY::Triangles> m_tri){
    double minArea = 100, maxArea = -100;
    if (TALYFEMLIB::GetMPIRank() == 0){
      for (int i = 0; i < m_tri.size(); i++){
        double Area_i = computeTriangleArea(m_tri[i].triangleCoord);
        if (minArea > Area_i){
          minArea = Area_i;
        }
        if (maxArea < Area_i){
          maxArea = Area_i;
        }
      }
    }

    PrintStatus("min Triangle Area =", minArea);
    PrintStatus("max Triangle Area =", maxArea);
    PrintStatus("Triangles =", m_tri.size());
  }

  void printStl2File(const std::string &fPrefix, GEOMETRY::STL *stl){
    if (TALYFEMLIB::GetMPIRank() == 0){ // if:master cpu, then:print
      std::vector<GEOMETRY::Triangles> m_triangles = stl->getTriangles();
      char fname[256];
      sprintf(fname, "%s.csv", fPrefix.c_str());
      std::ofstream fout(fname);
      fout << "x0,y0,z0,nx0,ny0,nz0\n";
      for (const auto &m_triangle : m_triangles){
        for (int dim = 0; dim < DIM; dim++){
          fout << m_triangle.triangleCoord[dim][0] << "," << m_triangle.triangleCoord[dim][1] << ","
               << m_triangle.triangleCoord[dim][2] << ","
               << m_triangle.normal[0] << "," << m_triangle.normal[1]
               << "," << m_triangle.normal[2] << " \n";
        }
      }
      fout.close();
    }
  }

  void ChangingGaussPointsFormat(const std::vector<NodeAndValues<DENDRITE_REAL>> &gaussPoints,
                                 std::vector<ZEROPTV> &GPPTV){
    GPPTV.resize(gaussPoints.size());
    int counter = -1;
    for (const auto &gp : gaussPoints){
      ZEROPTV gpptv_local;
      counter++;
      for (int dim = 0; dim < DIM; dim++){
        GPPTV[counter](dim) = gp.location[dim];
#if (DIM == 2)
        GPPTV[counter](2) = 0;
#endif
      }
    }
  }

  void ChangingGaussPointsFormatWithNormal(const std::vector<NodeAndValues<DENDRITE_REAL>> &gaussPoints,
                                           std::vector<ZEROPTV> &GPPTV, std::vector<ZEROPTV> &NORMALPTV){
    GPPTV.resize(gaussPoints.size());
    NORMALPTV.resize(gaussPoints.size());
    int counter = -1;
    for (const auto &gp : gaussPoints){
      ZEROPTV gpptv_local;
      counter++;
      for (int dim = 0; dim < DIM; dim++){
        GPPTV[counter](dim) = gp.location[dim];
        NORMALPTV[counter](dim) = gp.normal[dim];
#if (DIM == 2)
        GPPTV[counter](2) = 0;
        NORMALPTV[counter](2) = 0;
#endif
      }
    }
  }

  void STL2zeroPTV(const std::vector<GEOMETRY::STL *> &stls,
                   std::vector<TALYFEMLIB::ZEROPTV> &points){
    std::vector<GEOMETRY::Triangles> m_triangles = stls[0]->getTriangles();
    int PtSize = m_triangles.size();
    points.resize(PtSize);
    for (int i = 0; i < PtSize; i++){
      for (int dim = 0; dim < DIM; dim++){
        points[i](dim) = (m_triangles[i].triangleCoord[0][dim] + m_triangles[i].triangleCoord[1][dim] + m_triangles[i].triangleCoord[2][dim]) / 3;
      }
    }
  }

  void all_together(const std::vector<TALYFEMLIB::ZEROPTV> pts_position, std::vector<TALYFEMLIB::ZEROPTV> &pts_position_all){
    int nProc = TALYFEMLIB::GetMPISize(); // be careful
    int numNodes = pts_position.size();
    std::vector<int> eachProcData(nProc);
    MPI_Allgather(&numNodes, 1, MPI_INT, eachProcData.data(), 1, MPI_INT, MPI_COMM_WORLD);

    std::vector<int> disp(nProc, 0);
    for (int i = 1; i < disp.size(); i++){
      disp[i] = disp[i - 1] + eachProcData[i - 1];
    }

    int totalProcData = 0;
    for (int i = 0; i < nProc; i++){
      totalProcData += eachProcData[i];
    }

    if (TALYFEMLIB::GetMPIRank() == 0){
      pts_position_all.resize(totalProcData);
    }

    MPI_Datatype ZEROPTVtype;
    MPI_Type_contiguous(3, MPI_DOUBLE, &ZEROPTVtype);
    MPI_Type_commit(&ZEROPTVtype);
    MPI_Gatherv(pts_position.data(), pts_position.size(), ZEROPTVtype, pts_position_all.data(), eachProcData.data(), disp.data(), ZEROPTVtype, 0, MPI_COMM_WORLD);
  }

  void ToEachProcessor(const std::vector<TALYFEMLIB::ZEROPTV> pts_position, std::vector<TALYFEMLIB::ZEROPTV> &pts_position_all){
    int nProc = TALYFEMLIB::GetMPISize(); // be careful
    int numNodes = pts_position.size();
    std::vector<int> eachProcData(nProc);
    MPI_Allgather(&numNodes, 1, MPI_INT, eachProcData.data(), 1, MPI_INT, MPI_COMM_WORLD);

    std::vector<int> disp(nProc, 0);
    for (int i = 1; i < disp.size(); i++){
      disp[i] = disp[i - 1] + eachProcData[i - 1];
    }

    int totalProcData = 0;
    for (int i = 0; i < nProc; i++){
      totalProcData += eachProcData[i];
    }

    pts_position_all.resize(totalProcData);

    MPI_Datatype ZEROPTVtype;
    MPI_Type_contiguous(3, MPI_DOUBLE, &ZEROPTVtype);
    MPI_Type_commit(&ZEROPTVtype);
    MPI_Allgatherv(pts_position.data(), pts_position.size(), ZEROPTVtype, pts_position_all.data(), eachProcData.data(), disp.data(), ZEROPTVtype, MPI_COMM_WORLD);
  }

  void print_Point(const std::string &fPrefix, const std::vector<TALYFEMLIB::ZEROPTV> &pts_position_all){
    if (TALYFEMLIB::GetMPIRank() == 0){ // if:master cpu, then:print
      FILE *fp = fopen(fPrefix.c_str(), "w");

#if (DIM == 2)
      fprintf(fp, "x0,y0\n");
#endif
#if (DIM == 3)
      fprintf(fp, "x0,y0,z0\n");
#endif

      for (int i = 0; i < pts_position_all.size(); i++){
#if (DIM == 2)
        fprintf(fp, "%.10e,%.10e\n",
                pts_position_all[i](0), pts_position_all[i](1));
#endif
#if (DIM == 3)
        fprintf(fp, "%.10e,%.10e,%.10e\n",
                pts_position_all[i](0), pts_position_all[i](1), pts_position_all[i](2));
#endif
      }

      fclose(fp);
    }
  }

  void print_PointandNormal(const std::string &fPrefix, const std::vector<TALYFEMLIB::ZEROPTV> &pts_position_all, const std::vector<TALYFEMLIB::ZEROPTV> &pts_normal_all){
    if (TALYFEMLIB::GetMPIRank() == 0){ // if:master cpu, then:print
      FILE *fp = fopen(fPrefix.c_str(), "w");

#if (DIM == 2)
      fprintf(fp, "x0,y0,nx0,ny0\n");
#endif
#if (DIM == 3)
      fprintf(fp, "x0,y0,z0,nx0,ny0,nz0\n");
#endif

      for (int i = 0; i < pts_position_all.size(); i++){
#if (DIM == 2)
        fprintf(fp, "%.10e,%.10e,%.10e,%.10e\n",
                pts_position_all[i](0), pts_position_all[i](1), pts_normal_all[i](0), pts_normal_all[i](1));
#endif
#if (DIM == 3)
        fprintf(fp, "%.10e,%.10e,%.10e,%.10e,%.10e,%.10e\n",
                pts_position_all[i](0), pts_position_all[i](1), pts_position_all[i](2), pts_normal_all[i](0), pts_normal_all[i](1), pts_normal_all[i](2));
#endif
      }

      fclose(fp);
    }
  }

    void Local2Global(const int &local, int &global, MPI_Comm comm){
        MPI_Reduce(&local, &global, 1, MPI_INT, MPI_SUM, 0, comm);
    }

    void Local2Global(const double &local, double &global, MPI_Comm comm){
        MPI_Reduce(&local, &global, 1, MPI_DOUBLE, MPI_SUM, 0, comm);
    }

    void PrintPT2File(const std::vector<ZEROPTV> &PT,const std::string &fPrefix){
        std::vector<ZEROPTV> PTGlobal;

        int nProc = TALYFEMLIB::GetMPISize(); // be careful
        int numNodes = PT.size();
        std::vector<int> eachProcData(nProc);
        MPI_Allgather(&numNodes, 1, MPI_INT, eachProcData.data(), 1, MPI_INT, MPI_COMM_WORLD);

        std::vector<int> disp(nProc, 0);
        for (int i = 1; i < disp.size(); i++){
            disp[i] = disp[i - 1] + eachProcData[i - 1];
        }

        int totalProcData = 0;
        for (int i = 0; i < nProc; i++){
            totalProcData += eachProcData[i];
        }

        if (TALYFEMLIB::GetMPIRank() == 0){
            PTGlobal.resize(totalProcData);
        }

        MPI_Datatype ZEROPTVtype;
        MPI_Type_contiguous(3, MPI_DOUBLE, &ZEROPTVtype);
        MPI_Type_commit(&ZEROPTVtype);
        MPI_Gatherv(PT.data(), PT.size(), ZEROPTVtype, PTGlobal.data(), eachProcData.data(), disp.data(), ZEROPTVtype, 0, MPI_COMM_WORLD);

        if (TALYFEMLIB::GetMPIRank() == 0){ // if:master cpu, then:print
            FILE *fp = fopen(fPrefix.c_str(), "w");

#if (DIM == 2)
            fprintf(fp, "x,y\n");
#endif
#if (DIM == 3)
            fprintf(fp, "x,y,z\n");
#endif

            for (int i = 0; i < PTGlobal.size(); i++){
#if (DIM == 2)
                fprintf(fp, "%.10e,%.10e\n",
                        PTGlobal[i](0), PTGlobal[i](1));
#endif
#if (DIM == 3)
                fprintf(fp, "%.10e,%.10e,%.10e\n",
                        PTGlobal[i](0), PTGlobal[i](1),PTGlobal[i](2));
#endif
            }

            fclose(fp);
        }
    }

    /**
   * Calculates the L2 error of two vectors, used in block iteration.
   * @param[in] vec_u first of the two vectors for comparison
   * @param[in] vec_block second of the two vectors for comparison
   * @param[in] ndof ndof of the vector
   * @return
   */
  static double calc_error(Vec vec_u, Vec vec_block, const unsigned int ndof, MPI_Comm comm){
    PetscInt size;
    VecGetLocalSize(vec_u, &size);
    PetscInt low;
    VecGetOwnershipRange(vec_u, &low, nullptr);

    const PetscScalar *u;
    const PetscScalar *block;
    VecGetArrayRead(vec_u, &u);
    VecGetArrayRead(vec_block, &block);

    std::vector<double> totalU(ndof, 0.0);   // holds sum of u^2 at every node
    std::vector<double> totalErr(ndof, 0.0); // holds sum of (u - u_block)^2 at every node
    for (PetscInt i = 0; i < size; i++){
      const unsigned int dof = (low + i) % ndof;
      totalU[dof] += u[i] * u[i];
      double diff = u[i] - block[i];
      totalErr[dof] += diff * diff;
    }

    VecRestoreArrayRead(vec_u, &u);
    VecRestoreArrayRead(vec_block, &block);

    std::vector<double> allU(ndof);
    std::vector<double> allErrs(ndof);
    MPI_Allreduce(totalU.data(), allU.data(), ndof, MPI_DOUBLE, MPI_SUM, comm);
    MPI_Allreduce(totalErr.data(), allErrs.data(), ndof, MPI_DOUBLE, MPI_SUM, comm);
    totalU.clear();
    totalErr.clear();
    double largest = -1e16;
    for (unsigned int dof = 0; dof < ndof; dof++){
      double err = allErrs[dof] / (allU[dof] + 1e-12);
      if (std::isnan(err) || std::isinf(err)){
        throw TALYFEMLIB::TALYException() << "Infinity or NAN in block error";
      }

      if (err > largest){
        largest = err;
      }
    }
    return sqrt(largest);
  }

  /**
   * Save the octree mesh to vtk binary file.
   */
  void save_timestep(DA *octDA,
                               const std::vector<TREENODE> &treePartition,
                               Vec vec,
                               unsigned int ndof,
                               const TimeInfo &ti,
                               const SubDomain &subDomain,
                               const std::string &prefix = "timestep",
                               const char **varName = nullptr
  ){
    // create directory for this timestep (if it doesnt already exist)
    char folder[PATH_MAX];
    snprintf(folder, sizeof(folder), "results_%05d", ti.getTimeStepNumber());
    int ierr = mkdir(folder, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
    if (ierr != 0 && errno != EEXIST){
      PrintError("Could not create folder for storing results (", strerror(errno), ").");
      return;
    }

    char fname[PATH_MAX];
    snprintf(fname, sizeof(fname), "%s_%05d", prefix.c_str(), ti.getTimeStepNumber());
    PETSc::petscVectopvtu(octDA, treePartition, vec, folder, fname, varName,
                          subDomain.domainExtents(), false, false, ndof);
  }

  void save_data(DA *octDA,
                 const std::vector<TREENODE> &treePartition,
                 Vec solution,
                 const heat3dInputData &idata,
                 const TimeInfo &ti,
                 const SubDomain &subDomain,
                 const char **varname){
    
    save_timestep(octDA, treePartition, solution, heat3dNodeData::NUM_VARS, ti, subDomain, "heat3d", varname);
  }

  void performRefinementSubDA(DA *&octDA, const std::vector<TREENODE> &treeNode, DomainExtents &domainExtents, DistTREE &dTree,
                              heat3dInputData &inputData, SubDomain *subdomain){
    int no_refine = 0;
    while (true){
      SubDomainBoundary subDomainBoundary(subdomain, octDA, domainExtents);

      heat3dRefine refine(octDA, treeNode, domainExtents, &inputData, &subDomainBoundary);
      DA *newDA = refine.getRefineSubDA(dTree);
      if (newDA == NULL){
        newDA = refine.getForceRefineSubDA(dTree);
        std::swap(newDA, octDA);
        break;
      }

      std::swap(newDA, octDA);

      delete newDA;

      subdomain->finalize(octDA, dTree.getTreePartFiltered(), domainExtents);
      TALYFEMLIB::PrintStatus("Refinement ", no_refine, ", mesh count (node) = ", octDA->getGlobalNodeSz());
      no_refine++;
    }
  }

  void performRefinementSubDAIBM(DA *&octDA, const std::vector<TREENODE> &treeNode, DomainExtents &domainExtents, DistTREE &dTree,
                                 heat3dInputData &inputData, SubDomain *subdomain, std::vector<GEOMETRY::Geometry *> ibm_geoms, bool doCoarsen = false){
    int no_refine = 0;
    while (no_refine < 36){
      SubDomainBoundary subDomainBoundary(subdomain, octDA, domainExtents);
      heat3dRefine refine(octDA, treeNode, domainExtents, &inputData, &subDomainBoundary, ibm_geoms, doCoarsen);
      DA *newDA = refine.getRefineSubDA(dTree);
      if (newDA == NULL){
        break;
      }

      std::swap(newDA, octDA);

      delete newDA;
      subdomain->finalize(octDA, dTree.getTreePartFiltered(), domainExtents);
      PrintStatus("Refinement ", no_refine, ", mesh count (node) = ", octDA->getGlobalNodeSz());
      no_refine++;
    }
  }

  
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////////
  // These will be removed.
  // These calculations will be done in main or aren't used yet.
  
  // void refineAndIntergrid(DA *&octDA,
  //                         DistTREE &dTree,
  //                         DomainExtents &domainExtents,
  //                         heat3dInputData &inputData,
  //                         SubDomainBoundary *boundary,
  //                         Vec &vecHT1, Vec &vecHT2, Vec &vecHT3, Vec &vecHT4,
  //                         const char **ht_varname,
  //                         TimerGroup<MPITimer> &timers,
  //                         std::map<std::string, int> &timer_tags){
  //   int no_refine = 0;
  //   while (true){
  //     TALYFEMLIB::PrintStatus("Active comm = ",
  //                             octDA->getNpesActive(),
  //                             ", no_refine = ",
  //                             no_refine,
  //                             ", mesh count (node) = ",
  //                             octDA->getGlobalNodeSz());
                              
  //     heat3dRefine daRefine(octDA, dTree.getTreePartFiltered(), domainExtents, &inputData, boundary);
      
  //     DA *newDA = daRefine.getRefineSubDA(dTree);
  //     if (newDA == NULL){
  //       break;
  //     }
  //     timers.Start(timer_tags["initIntergridTransfer"]);
  //     daRefine.initPetscIntergridTransfer();
  //     timers.Stop(timer_tags["initIntergridTransfer"]);
  //     timers.Start(timer_tags["IntergridTransfer"]);
  //     daRefine.petscIntergridTransfer(newDA, dTree, vecHT1, heat3dNodeData::NUM_VARS);
  //     daRefine.petscIntergridTransfer(newDA, dTree, vecHT2, heat3dNodeData::NUM_VARS);
  //     daRefine.petscIntergridTransfer(newDA, dTree, vecHT3, heat3dNodeData::NUM_VARS);
  //     daRefine.petscIntergridTransfer(newDA, dTree, vecHT4, heat3dNodeData::NUM_VARS);
  //     timers.Stop(timer_tags["IntergridTransfer"]);
  //     daRefine.finializeIntergridTransfer();
  //     std::swap(octDA, newDA);
  //     delete newDA;
  //     no_refine++;
  //   }
  // }
  
  // /**
  //  * @brief sets vector with initial temperature. Must be allocated outside.
  //  * @param octDA
  //  * @param inputData
  //  * @param [out] Solution the final vector with temperature
  //  */
  // void setInitialConditionHT(DA *octDA, heat3dInputData &inputData, Vec &Solution)
  // {
  //   std::function<void(const double *, double *)> initial_condition = [&](const double *x, double *var)
  //   {
  //     /// HT only has 1 dof and should be accessed as var[0]
  //     if (inputData.dump_vec &&
  //         inputData.boundary_def[1].bc_type == BoundaryDef::Temperature_Type::ROBIN_T)
  //     {
  //       var[0] = 100 * (1.0 - x[0] / 3);
  //     }
  //     else
  //     {
  //       var[0] = inputData.ic_def.t_ic;
  //     }
  //   };

  //   octDA->petscSetVectorByFunction(Solution, initial_condition, false, false, heat3dNodeData::NUM_VARS);
  // }

  // void calculateNuCarvedOut(DA *octDA, const std::vector<TREENODE> &treePart, Vec htSolution,
  //                           const DomainExtents &domainExtents, SubDomainBoundary *subDomainBoundary,
  //                           heat3dInputData &inputData, const TimeInfo ti)
  // {
  //   for (DENDRITE_UINT no_object = 0; no_object < inputData.carved_out_geoms_def.size(); no_object++)
  //   {
  //     DENDRITE_REAL globalNu[2];
  //     VecInfo vec(htSolution, heat3dNodeData::NUM_VARS, heat3dNodeData::TEMPERATURE);
  //     PostProcessCalc nuCalc(octDA, treePart, vec, domainExtents,
  //                            inputData.getDiffusionHT(ti.getCurrentTime()),
  //                            subDomainBoundary, no_object, PostProcessCalc::NU);
  //     nuCalc.getTotalNu(globalNu);
  //     if (TALYFEMLIB::GetMPIRank() == 0)
  //     {
  //       std::string fname = "Nu_" + std::to_string(no_object) + ".dat";
  //       //      if (surface2cal_) {
  //       //        fname = "Force_" + to_string(surface2cal_) + ".dat";
  //       //      }
  //       FILE *fp = fopen(fname.c_str(), "a");
  //       if (!fp)
  //       {
  //         throw TALYException() << "Cannot create file: " << fname;
  //       }
  //       fprintf(fp,
  //               "Timestep: %1d, Time: %.5f\n"
  //               "Nu_normal = %.10e, Nu_penalty = %.10e\n",
  //               ti.getTimeStepNumber(),
  //               ti.getCurrentTime(),
  //               globalNu[0], globalNu[1]);

  //       fclose(fp);
  //       //      std::ofstream fout("Nu_" + std::to_string(no_object) + ".txt", std::ios::app);
  //       //      fout << ti.getCurrentTime() << " ";
  //       //      fout << globalNu[0] << " " << globalNu[1] << " ";
  //       //      fout << "\n";
  //       //      fout.close();
  //     }
  //   }
  // }

  // void printMinMaxValueHT(DA *octDA, Vec &sol)
  // {

  //   PetscScalar max[heat3dNodeData::NUM_VARS], min[heat3dNodeData::NUM_VARS];
  //   VecBounds<heat3dNodeData::NUM_VARS>::getMaxAndMinimumValues(sol, octDA->getCommActive(), max, min);
  //   for (int i = 0; i < heat3dNodeData::NUM_VARS; i++)
  //   {
  //     PrintStatus("dof:", i, " HT min/max: ", min[i], "/", max[i]);
  //   }
  // }

  // void setMinMaxValueHT(DA *octDA, Vec &sol, heat3dInputData &idata)
  // {
  //   if (idata.limiter.manual_limiter)
  //   {
  //     PetscScalar max[heat3dNodeData::NUM_VARS], min[heat3dNodeData::NUM_VARS];
  //     for (int i = 0; i < heat3dNodeData::NUM_VARS; i++)
  //     {
  //       min[i] = idata.limiter.lb[heat3dNodeData::TEMPERATURE + i];
  //       max[i] = idata.limiter.ub[heat3dNodeData::TEMPERATURE + i];
  //       PrintStatus("dof:", i, " Set HT min/max: ", min[i], "/", max[i]);
  //     }
  //     VecBounds<heat3dNodeData::NUM_VARS>::setMaxAndMinimumValues(sol, octDA->getCommActive(), max, min);
  //   }
  // }

  // void read_running_sum_step(const std::string &filename, int &running_step){
  //   if (TALYFEMLIB::GetMPIRank() == 0){
  //     std::fstream myfile(filename.c_str(), std::ios_base::in);
  //     if (myfile){
  //       myfile >> running_step;
  //       myfile.close();
  //     }
  //   }
  // }

  // void write_running_sum_step(const std::string &filename, const int &running_step){
  //   if (TALYFEMLIB::GetMPIRank() == 0){
  //     std::fstream myfile(filename.c_str(), std::ios_base::out);
  //     myfile << running_step;
  //   }
  // }

}



