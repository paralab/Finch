//This file was generated by Finch.

/*

*/
#pragma once

#include <TimeInfo.h>
#include <PETSc/BoundaryConditions.h>
#include <DataTypes.h>
#include "heat3dInputData.h"
#include "heat3dNodeData.h"

class heat3dBoundaryConditions {
public:
    heat3dBoundaryConditions(SubDomainBoundary *boundary, heat3dInputData *inputData, TimeInfo *time)
        : inputData_(inputData), time_(time), boundaries_(boundary){
        PrintInfo("Setting up boundary conditions");
    }
    
    /**
    * Method to setup Boundary conditions.
    * @param b Boundary object
    * @param position position
    */
    void setBoundaryConditions(PETSc::Boundary &b, const ZEROPTV &position){
        static const double eps = 1e-14;
        double t = time_->getCurrentTime();
        double x = position.x();
        double y = position.y();
        double z = position.z();
        Point<3> domainMin(inputData_->meshDef.physDomain.min);
        Point<3> domainMax(inputData_->meshDef.physDomain.max);

        
        // Check walls of full domain
        int wall_index = -1;
        if(fabs(x - inputData_->meshDef.physDomain.min[0]) < eps){ wall_index = 0;} // xmin
        else if(fabs(x - inputData_->meshDef.physDomain.max[0]) < eps){ wall_index = 1;} // xmax
        else if(fabs(y - inputData_->meshDef.physDomain.min[1]) < eps){ wall_index = 2;} // ymin
        else if(fabs(y - inputData_->meshDef.physDomain.max[1]) < eps){ wall_index = 3;} // ymax
#if (DIM == 3)
        else if(fabs(z - inputData_->meshDef.physDomain.min[2]) < eps){ wall_index = 4;} // zmin
        else if(fabs(z - inputData_->meshDef.physDomain.max[2]) < eps){ wall_index = 5;} // zmax
#endif
        
        // Define BIDs
    bool on_bid_1 = true;

        
        bool on_bid_array[1] = {on_bid_1};
        
        /// for carved out geometry
        // This is commented because currently generateBoundaryFlags only works for nodes
        // in the interior of a geometry. 
        /*
        DENDRITE_UINT objectID = -1;
        boundaries_->generateBoundaryFlags(position, objectID);
        if (boundaries_->checkBoundaryType(BoundaryTypes::VOXEL::SPHERE) or
            boundaries_->checkBoundaryType(BoundaryTypes::VOXEL::CIRCLE) or
            boundaries_->checkBoundaryType(BoundaryTypes::VOXEL::BOX) or
            boundaries_->checkBoundaryType(BoundaryTypes::VOXEL::GEOMETRY)){
            
            const auto &carved_geo = inputData_->carved_out_geoms_def.at(objectID);
            // Apply BC for each relevant BID and DOF
            // ...
        }
        */
        // If there is a geometry, use its BCs
        if(inputData_->carved_out_geoms_def.size() > 0){
            const auto &carved_geo = inputData_->carved_out_geoms_def.at(0);
            // Apply BC for each relevant BID and DOF
            unsigned int nbids = carved_geo.bc_type_V.size();
            for(int bidi = 0; bidi < nbids; bidi++){
                if(on_bid_array[bidi] && 
                    (carved_geo.bc_type_V[bidi] == CarvedOutGeom::BCType::SBM || 
                     carved_geo.bc_type_V[bidi] == CarvedOutGeom::BCType::DIRICHLET)){
                    // This position is part of a BID assigned to this geometry.
                    // If it is also a part of the global boundary or another geometry,
                    // Those will be ignored. Only one BC can be set for a given dof here.
                    // The first one found will be used.
    if(on_bid_1){
        b.addDirichlet(heat3dNodeData::u_1_dofind, genfunction_1(position, t));
    }
                    
                    return;
                }
            }
        }
        
        
        // Consider full domain boundaries if there is no geometry
        const auto boundary_def = inputData_->boundary_def;
        if(wall_index >= 0 && boundary_def[wall_index].bc_type == BoundaryDef::Condition_Type::DIRICHLET_BC){
    if(on_bid_1){
        b.addDirichlet(heat3dNodeData::u_1_dofind, genfunction_1(position, t));
    }
        }
        

        
        // This may be used at some point in the future.
        /*
        for (auto &r : inputData_->region_refine){
            if (r.forRetain){
                auto res = r.out_retain(position);
                if (res == RegionalRefine::RetainType::OUTSIDE){
                    b.addDirichlet(0, 0.0);
                    return;
                }else if (res == RegionalRefine::RetainType::ON_BOUNDARY){
                    // ??
                }
            }
        }
        */
    };
    
    /**
    * Returns a dirichlet boundary value.
    * @param value value
    * @param position position
    */
    void getBoundaryValue(const ZEROPTV &position, double* value){
        static const double eps = 1e-14;
        double t = time_->getCurrentTime();
        double x = position.x();
        double y = position.y();
        double z = position.z();
        Point<3> domainMin(inputData_->meshDef.physDomain.min);
        Point<3> domainMax(inputData_->meshDef.physDomain.max);

        
        // Check walls of full domain
        int wall_index = -1;
        if(fabs(x - inputData_->meshDef.physDomain.min[0]) < eps){ wall_index = 0;} // xmin
        else if(fabs(x - inputData_->meshDef.physDomain.max[0]) < eps){ wall_index = 1;} // xmax
        else if(fabs(y - inputData_->meshDef.physDomain.min[1]) < eps){ wall_index = 2;} // ymin
        else if(fabs(y - inputData_->meshDef.physDomain.max[1]) < eps){ wall_index = 3;} // ymax
#if (DIM == 3)
        else if(fabs(z - inputData_->meshDef.physDomain.min[2]) < eps){ wall_index = 4;} // zmin
        else if(fabs(z - inputData_->meshDef.physDomain.max[2]) < eps){ wall_index = 5;} // zmax
#endif
        
        // Define BIDs
    bool on_bid_1 = true;

        
        bool on_bid_array[1] = {on_bid_1};
        
        /// for carved out geometry
        // This is commented because currently generateBoundaryFlags only works for nodes
        // in the interior of a geometry. 
        /*
        DENDRITE_UINT objectID = -1;
        boundaries_->generateBoundaryFlags(position, objectID);
        if (boundaries_->checkBoundaryType(BoundaryTypes::VOXEL::SPHERE) or
            boundaries_->checkBoundaryType(BoundaryTypes::VOXEL::CIRCLE) or
            boundaries_->checkBoundaryType(BoundaryTypes::VOXEL::BOX) or
            boundaries_->checkBoundaryType(BoundaryTypes::VOXEL::GEOMETRY)){
            
            const auto &carved_geo = inputData_->carved_out_geoms_def.at(objectID);
            // Apply BC for each relevant BID and DOF
            // ...
        }
        */
        // If there is a geometry, use its BCs
        if(inputData_->carved_out_geoms_def.size() > 0){
            const auto &carved_geo = inputData_->carved_out_geoms_def.at(0);
            // Apply BC for each relevant BID and DOF
            unsigned int nbids = carved_geo.bc_type_V.size();
            for(int bidi = 0; bidi < nbids; bidi++){
                if(on_bid_array[bidi]){
                    // This position is part of a BID assigned to this geometry.
                    // If it is also a part of the global boundary or another geometry,
                    // Those will be ignored. Only one BC can be set for a given dof here.
                    // The first one found will be used.
    if(on_bid_1){
        value[heat3dNodeData::u_1_dofind] = genfunction_1(position, t);
    }
                    
                    return;
                }
            }
        }
        
        // Consider full domain boundaries if there is no geometry
        const auto boundary_def = inputData_->boundary_def;
        if(wall_index >= 0){
    if(on_bid_1){
        value[heat3dNodeData::u_1_dofind] = genfunction_1(position, t);
    }
        }

    };
    
    /**
    * Returns the BID at a position
    * @param position position
    */
    int getBoundaryID(const ZEROPTV &position){
        static const double eps = 1e-14;
        double x = position.x();
        double y = position.y();
        double z = position.z();
        Point<3> domainMin(inputData_->meshDef.physDomain.min);
        Point<3> domainMax(inputData_->meshDef.physDomain.max);
 
        
        // Check BIDs
    if(true){
        return 0;
    }

        
        // If it gets here, this position is not on a specified BID
        return -1;
    };
    
private:
    const heat3dInputData *inputData_;
    TimeInfo *time_;
    SubDomainBoundary *boundaries_;
    
    // boundary value functions /////////////////////////////////////////////////////
double genfunction_1(const TALYFEMLIB::ZEROPTV &pt, const double t){
        return exp((-(pt.z()) * pt.z()) / 0.04);
}


    /////////////////////////////////////////////////////////////////////////////////
};

