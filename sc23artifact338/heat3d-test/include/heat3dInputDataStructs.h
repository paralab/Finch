//This file was generated by Finch.

/*

*/
#pragma once
// #include "util.h"
#include "IMGA/IMGA.h"
#include "heat3dNodeData.h"

/// read size of 3 vector as ZEROPTV
void ReadZEROPTV(const libconfig::Setting &root, const std::string &key_name, ZEROPTV &value, bool required = true){
  if (root.exists(key_name.c_str())){
    if (root[key_name.c_str()].getLength() >= DIM){
      value(0) = (double)root[key_name.c_str()][0];
      value(1) = (double)root[key_name.c_str()][1];
#if (DIM == 2)
      value(2) = 0.0;
#endif
#if (DIM == 3)
      value(2) = (double)root[key_name.c_str()][2];
#endif
    }else{
      throw TALYException() << key_name + " have size of " + std::to_string(root[key_name.c_str()].getLength());
    }
  }else if (required){
    throw TALYException() << key_name + " doesn't exist!";
  }
}

/// Function for reading a vector from root
template <typename T>
void ReadVectorRoot(const libconfig::Setting &root, const std::string &key_name, std::vector<T> &value){
  const libconfig::Setting &config_v = root[key_name.c_str()];
  if (config_v.isNumber()){
    value.push_back(config_v);
  }else{
    value.reserve(config_v.getLength());
    for (int i = 0; i < config_v.getLength(); ++i){
      value.emplace_back(config_v[i]);
    }
  }
}

/*
 * maximum value of an array
 */
double maximum(std::array<DENDRITE_REAL, DIM> &array){
  DENDRITE_REAL max = array[0];
  for (int i = 1; i < DIM; i++){
    if (array[i] > max){
      max = array[i];
    }
  }
  return max;
}

/*
 * minimum value of an array
 */
double minimum(std::array<DENDRITE_REAL, DIM> &array){
  DENDRITE_REAL min = array[0];
  for (int i = 1; i < DIM; i++){
    if (array[i] < min){
      min = array[i];
    }
  }
  return min;
}

template <typename T>
void PrintVector(std::ofstream &fstream, const std::string &name, const std::vector<T> &vec){
  int rank = TALYFEMLIB::GetMPIRank();
  if (!rank && fstream.is_open()){
    fstream << name << ": [";
    for (const auto &v : vec){
      fstream << v << ", ";
    }
    fstream << "]\n";
  }
}

/**
 * Domain definition
 */
struct MeshDef{
  DomainInfo fullDADomain; /// The domain from which its carved out.
  DomainInfo physDomain;   /// The actual SubDAdomain

  std::array<DENDRITE_REAL, DIM> max; ///< max of domain
  std::array<DENDRITE_REAL, DIM> min; ///< min of domain

  ///< Dendro options
  DENDRITE_UINT refineLevel_base;
  DENDRITE_UINT refineLevel_channel_wall;
  /// refineLevel_interface

  bool refine_walls[6] = {false, false, false, false, false, false}; ///< whether or not fx_refine refines at min/max
  bool refine_any_wall = false;

  void read_from_config(const libconfig::Setting &root){

    refineLevel_base = (unsigned int)root["refineLevel"];

    max[0] = (DENDRITE_REAL)root["max"][0];
    max[1] = (DENDRITE_REAL)root["max"][1];
    min[0] = (DENDRITE_REAL)root["min"][0];
    min[1] = (DENDRITE_REAL)root["min"][1];
#if (DIM == 3)
    max[2] = (DENDRITE_REAL)root["max"][2];
    min[2] = (DENDRITE_REAL)root["min"][2];
#endif

    //if (!root.lookupValue("refine_walls", refine_walls)){
      // refine_walls = {false...}; // initialized to false
    //}else{
      refine_walls[0] = root["refine_walls"][0];
      refine_walls[1] = root["refine_walls"][1];
      refine_walls[2] = root["refine_walls"][2];
      refine_walls[3] = root["refine_walls"][3];
      refine_any_wall = refine_walls[0] || refine_walls[1] || refine_walls[2] || refine_walls[3];
#if (DIM == 3)
      refine_walls[4] = root["refine_walls"][4];
      refine_walls[5] = root["refine_walls"][5];
      refine_any_wall = refine_any_wall || refine_walls[4] || refine_walls[5];
#endif
    //}

    if (refine_any_wall){
      refineLevel_channel_wall = (unsigned int)root["refineLevel_channel_wall"];
      // refineLevel_pillar_wall = (unsigned int)root["refineLevel_pillar_wall"];
      if (refineLevel_base < 1 || refineLevel_base >= 31 ||
          refineLevel_channel_wall < 1 || refineLevel_channel_wall >= 31)
      {
        PrintWarning("Invalid refine_ level - should be 1 < refineLevel <= 31.");
      }
    }
    if (!refine_any_wall){
      refineLevel_channel_wall = refineLevel_base;
    }

    if (refineLevel_base > refineLevel_channel_wall){
      PrintWarning("refineLevel_base > refineLevel_channel_wall");
    }

    double minOfBox = minimum(min);
    double sizeOfBox = maximum(max);

    fullDADomain.min.fill(minOfBox);
    fullDADomain.max.fill(sizeOfBox);

    physDomain.min[0] = min[0];
    physDomain.min[1] = min[1];
    physDomain.max[0] = max[0];
    physDomain.max[1] = max[1];
#if (DIM == 3)
    physDomain.min[2] = min[2];
    physDomain.max[2] = max[2];
#endif

  }

  void PrintMeshDef(std::ofstream &fstream){
    int rank = TALYFEMLIB::GetMPIRank();
    if (!rank && fstream.is_open()){
      fstream << "max: [";
      for (int i = 0; i < DIM; i++){
        fstream << max[i] << ", ";
      }
      fstream << "]\n";

      fstream << "fullDADomain-min: [";
      for (int i = 0; i < DIM; i++){
        fstream << fullDADomain.min[i] << ", ";
      }
      fstream << "]\n";
      fstream << "fullDADomain-max: [";
      for (int i = 0; i < DIM; i++){
        fstream << fullDADomain.max[i] << ", ";
      }
      fstream << "]\n";

      fstream << "physDomain-min: [";
      for (int i = 0; i < DIM; i++){
        fstream << physDomain.min[i] << ", ";
      }
      fstream << "]\n";
      fstream << "physDomain-max: [";
      for (int i = 0; i < DIM; i++){
        fstream << physDomain.max[i] << ", ";
      }
      fstream << "]\n";

      fstream << "refineLevel_base: " << refineLevel_base << "\n";
      fstream << "refineLevel_channel_wall: " << refineLevel_channel_wall << "\n";
      fstream << "refine_walls: [";
      for (int i = 0; i < DIM; i++){
        fstream << refine_walls[i*2] << ", ";
        fstream << refine_walls[i*2+1] << ", ";
      }
      fstream << "]\n";
    }
  }
};

/**
 * Parameters for boundary condition
 */
struct BoundaryDef{
  enum Side{
    INVALID = -1,
    X_MINUS = 0,
    X_PLUS = 1,
    Y_MINUS = 2,
    Y_PLUS = 3,
    Z_MINUS = 4,
    Z_PLUS = 5,
  };
  enum Condition_Type{
    NO_GRADIENT_BC = 0,
    DIRICHLET_BC = 1,
    NEUMANN_BC = 2,
    ROBIN_BC = 3,
    WEAK_BC = 4,
    CSV_BC = 5,
    CSV_WEAK_BC = 6,
    SBM_BC = 7,
    NEUMANN_SBM_BC =8
  };

  Side side = INVALID;
  Condition_Type bc_type = DIRICHLET_BC;
  /// for Dirichlet BC
  std::vector<DENDRITE_REAL> dirichlet_val;
  /// for Neumann BC
  std::vector<DENDRITE_REAL> flux;
  /// for robin BC
  std::vector<DENDRITE_REAL> G_vec;
  std::vector<DENDRITE_REAL> a_vec;
  
  bool ifRefine = false;

  static Side read_side_from_config(const libconfig::Setting &root){
    return str_to_side(root["side"]);
  }

  void read_from_config(const libconfig::Setting &root){
    if (root.exists("ifRefine")){
      ifRefine = (bool)root["ifRefine"];
    }
    if (root.exists("bc_type")){
      bc_type = read_bc_type(root["bc_type"]);
    }
    
    //if ((bc_type == Condition_Type::DIRICHLET_BC) || (bc_type == Condition_Type::WEAK_BC) || (bc_type == Condition_Type::SBM_BC)){
    //  ReadVectorRoot(root, "dirichlet_val", dirichlet_val);
    //}

    //if (bc_type == Condition_Type::NEUMANN_BC){
    //  ReadVectorRoot(root, "flux", flux);
    //}

    //if (bc_type == Condition_Type::ROBIN_BC){
    //  /// b * \frac{\partial u}{\partial n} = g - a * u
    //  ReadVectorRoot(root, "G_constant", G_vec);
    //  ReadVectorRoot(root, "a_constant", a_vec);
    //}
  }

  void PrintBoundaryDef(std::ofstream &fstream) const{
    int rank = TALYFEMLIB::GetMPIRank();
    if (!rank && fstream.is_open()){
      if (side == Side::INVALID){
        fstream << "side: INVALID\n";
      }else if (side == Side::X_MINUS){
        fstream << "side: X_MINUS\n";
      }else if (side == Side::X_PLUS){
        fstream << "side: X_PLUS\n";
      }else if (side == Side::Y_MINUS){
        fstream << "side: Y_MINUS\n";
      }else if (side == Side::Y_PLUS){
        fstream << "side: Y_PLUS\n";
      }else if (side == Side::Z_MINUS){
        fstream << "side: Z_MINUS\n";
      }else if (side == Side::Z_PLUS){
        fstream << "side: Z_PLUS\n";
      }
      
      if (bc_type == Condition_Type::NO_GRADIENT_BC){
        fstream << "bc_type: NO_GRADIENT_T\n";
      }else if (bc_type == Condition_Type::DIRICHLET_BC){
        fstream << "bc_type: DIRICHLET_T\n";
      }else if (bc_type == Condition_Type::NEUMANN_BC){
        fstream << "bc_type: NEUMANN_T\n";
      }else if (bc_type == Condition_Type::ROBIN_BC){
        fstream << "bc_type: ROBIN_T\n";
      }else if (bc_type == Condition_Type::WEAK_BC){
        fstream << "bc_type: WEAK_T\n";
      }

      //PrintVector(fstream, "dirichlet_val", dirichlet_val);
      //PrintVector(fstream, "flux", flux);
      //PrintVector(fstream, "G_vec", G_vec);
      //PrintVector(fstream, "a_vec", a_vec);
      fstream << "ifRefine: " << ifRefine << "\n";
    }
  }

private:
  static Side str_to_side(const std::string &str){
    if (str == "x-"){
      return Side::X_MINUS;
    }else if (str == "x+"){
      return Side::X_PLUS;
    }else if (str == "y-"){
      return Side::Y_MINUS;
    }else if (str == "y+"){
      return Side::Y_PLUS;
    }else if (str == "z-"){
      return Side::Z_MINUS;
    }else if (str == "z+"){
      return Side::Z_PLUS;
    }else{
      throw TALYFEMLIB::TALYException() << "Invalid BC side";
    }
  }

  static Condition_Type read_bc_type(const std::string &str){
    if (str == "no_gradient"){
      return Condition_Type::NO_GRADIENT_BC;
    }else if (str == "dirichlet"){
      return Condition_Type::DIRICHLET_BC;
    }else if (str == "neumann"){
      return Condition_Type::NEUMANN_BC;
    }else if (str == "robin"){
      return Condition_Type::ROBIN_BC;
    }else if (str == "weak"){
      return Condition_Type::WEAK_BC;
    }else if (str == "sbm"){
      return Condition_Type::SBM_BC;
    }else if (str == "csv"){
      return Condition_Type::CSV_BC;
    }else if (str == "csv_weak"){
      return Condition_Type::CSV_WEAK_BC;
    }else if (str == "neumann_sbm"){
        return Condition_Type::NEUMANN_SBM_BC;
    }else{
      throw TALYFEMLIB::TALYException() << "Invalid BC type for dirichlet_val";
    }
  }
};

/**
 * Parameters for initial condition
 */
struct InitialConditionDef{
  enum T_IC{
    ZERO_T = 0,
    USER_DEFINED_T = 1
  };

  T_IC t_ic_type = ZERO_T;
  double t_ic = 0.0;

  void read_from_config(const libconfig::Setting &root){
    if (root.exists("t_ic_type")){
      t_ic_type = read_dirichlet_val_ic(root["t_ic_type"]);
    }
    if (t_ic_type == T_IC::USER_DEFINED_T){
      t_ic = (double)root["t_ic"];
    }
  }

  void PrintInitialConditionDef(std::ofstream &fstream) const{
    int rank = TALYFEMLIB::GetMPIRank();
    if (!rank && fstream.is_open()){
      if (t_ic_type == T_IC::ZERO_T)
      {
        fstream << "t_ic_type: ZERO_T\n";
      }
      else if (t_ic_type == T_IC::USER_DEFINED_T)
      {
        fstream << "t_ic_type: USER_DEFINED_T\n";
      }
      fstream << "t_ic: " << t_ic << "\n";
    }
  }

protected:
  static T_IC read_dirichlet_val_ic(const std::string &str){
    if (str == "zero"){
      return T_IC::ZERO_T;
    }else if (str == "user_defined"){
      return T_IC::USER_DEFINED_T;
    }else{
      throw TALYFEMLIB::TALYException() << "Invalid IC type for dirichlet_val";
    }
  }
};

/**
 * Parameters for Regional refine
 */
struct RegionalRefine{
  enum RetainType{
    OUTSIDE = 0,
    INSIDE = 1,
    ON_BOUNDARY = 2,
  };
  enum Type{
    INVALID = -1,
    CUBE = 0,
    SPHERE = 1,
    CYLINDER = 2,
    MESHOBJECT = 10,
    MESHOBJECT_2D = 11,
  };
  bool forRetain = false;
  // max refinement level
  int refine_region_lvl = 0;
  int refine_region_lvl_boundary = 0;
  std::string mesh_path;
  ZEROPTV shift;
  GEOMETRY::Geometry *geometry;
  GEOMETRY::STL *stl;
  GEOMETRY::MSH *msh;

  void read_from_config(const libconfig::Setting &root){
    if (root.exists("forRetain")){
      forRetain = (bool)root["forRetain"];
    }
    refine_type = read_type(root["type"]);
    if (forRetain){
      if (refine_type != CUBE && refine_type != MESHOBJECT){
        throw TALYException() << "Not supported retain type!";
      }
    }else{
      refine_region_lvl = (int)root["refine_region_lvl"];
      refine_region_lvl_boundary = refine_region_lvl;
      if (root.exists("refine_region_lvl_boundary"))
      {
        refine_region_lvl_boundary = (int)root["refine_region_lvl_boundary"];
      }
    }
    if (refine_type == CUBE){
      ReadZEROPTV(root, "min_c", min_corner);
      ReadZEROPTV(root, "max_c", max_corner);
    }
#if (DIM == 3)
    if (refine_type == MESHOBJECT){
      mesh_path = (const char *)root["mesh_path"];
      ReadZEROPTV(root, "shift", shift);

      stl = new GEOMETRY::STL(mesh_path, GEOMETRY::InOutTest::RAY_TRACING);
      std::array<DENDRITE_REAL, DIM> point;
      point[0] = shift[0];
      point[1] = shift[1];
      point[2] = shift[2];
      geometry = new GEOMETRY::Geometry(stl, Point<DIM>(point));
    }
#endif

#if (DIM == 2)
    if (refine_type == MESHOBJECT_2D){
      mesh_path = (const char *)root["mesh_path"];
      ReadZEROPTV(root, "shift", shift);

      msh = new GEOMETRY::MSH(mesh_path, GEOMETRY::InOutTest2D::RAY_TRACING_2D);
      std::array<DENDRITE_REAL, DIM> point;
      point[0] = shift[0];
      point[1] = shift[1];
      geometry = new GEOMETRY::Geometry(msh, Point<DIM>(point));
    }
#endif
    if (refine_type == SPHERE){
      ReadZEROPTV(root, "center", center_sphere);
      radius_sphere = (double)root["radius"];
      if (root.exists("radius_in")){
        radius_sphere_in = (double)root["radius_in"];
      }
    }
    if (refine_type == CYLINDER){
      ReadZEROPTV(root, "c1", min_corner);
      ReadZEROPTV(root, "c2", max_corner);
      radius_cylinder = (double)root["radius"];
      if (root.exists("radius_in")){
        radius_cylinder_in = (double)root["radius_in"];
      }
    }
  }

public:
  /**
   * @return true for outside retain cube (boundary nodes included (for apply BC)), false for inside retain cube
   */
  RetainType out_retain(ZEROPTV p){
    if (not(forRetain)){
      throw TALYException() << "Calling function with forRetain = false";
    }
    switch (refine_type){
    case CUBE:{
      const double eps = 1e-8;
      if (p.x() < min_corner.x() - eps ||
          p.y() < min_corner.y() - eps ||
          p.z() < min_corner.z() - eps ||
          p.x() > max_corner.x() + eps ||
          p.y() > max_corner.y() + eps ||
          p.z() > max_corner.z() + eps)
      {
        return OUTSIDE;
      }else if (p.x() > min_corner.x() + eps &&
               p.y() > min_corner.y() + eps &&
               p.z() > min_corner.z() + eps &&
               p.x() < max_corner.x() - eps &&
               p.y() < max_corner.y() - eps &&
               p.z() < max_corner.z() - eps)
      {
        return INSIDE;
      }else{
        return ON_BOUNDARY;
      }
    }
    break;
    
    case MESHOBJECT:{
      bool ifInside = geometry->ifInside(p.data());
      if (ifInside){
        return INSIDE;
      }else{
        return OUTSIDE;
      }
    }
    break;
    
    default:
      throw TALYFEMLIB::TALYException() << "Wrong type with in/out test for retain!";
    }
  }

  /**
   * @return false for outside region, true for inside region
   */
  bool in_region(ZEROPTV p){
    if (forRetain){
      throw TALYException() << "Calling function with forRetain = true";
    }
    switch (refine_type){
    case CUBE:{
      return !(p.x() < min_corner.x() ||
               p.y() < min_corner.y() ||
               p.z() < min_corner.z() ||
               p.x() > max_corner.x() ||
               p.y() > max_corner.y() ||
               p.z() > max_corner.z());
    }
    break;
    
    case SPHERE:{
      double distance = (p - center_sphere).norm();
      return (distance < radius_sphere && distance > radius_sphere_in);
    }
    break;
    
    case CYLINDER:{
      ZEROPTV AB = min_corner - max_corner;
      ZEROPTV temp = AB * (1.0 / AB.innerProduct(AB));
      ZEROPTV AP = p - max_corner;
      ZEROPTV proj_point = max_corner + temp * AP.innerProduct(AB);
      double distance_s = (proj_point - p).innerProduct(proj_point - p);
      if (distance_s < radius_cylinder * radius_cylinder && (distance_s - radius_cylinder_in * radius_cylinder_in) > -1e-6){
        double max_x = std::max(max_corner.x(), min_corner.x());
        double max_y = std::max(max_corner.y(), min_corner.y());
        double max_z = std::max(max_corner.z(), min_corner.z());
        double min_x = std::min(max_corner.x(), min_corner.x());
        double min_y = std::min(max_corner.y(), min_corner.y());
        double min_z = std::min(max_corner.z(), min_corner.z());
        return !(proj_point.x() > max_x ||
                 proj_point.y() > max_y ||
                 proj_point.z() > max_z ||
                 proj_point.x() < min_x ||
                 proj_point.y() < min_y ||
                 proj_point.z() < min_z);
      }else{
        return false;
      }
    }
    break;
    
    case MESHOBJECT:{
      bool ifInside = geometry->ifInside(p.data());
      return ifInside;
    }
    
    case MESHOBJECT_2D:{
      bool ifInside = geometry->ifInside(p.data());
      return ifInside;
    }
    break;
    
    default:
      throw TALYFEMLIB::TALYException() << "Wrong type!";
    }
  }

  Type GetRefineType() const{
    return refine_type;
  }

  void PrintRegionRefineDef(std::ofstream &fstream) const{
    int rank = TALYFEMLIB::GetMPIRank();
    if (!rank && fstream.is_open()){
      if (refine_type == Type::INVALID){
        fstream << "refine_type: INVALID\n";
      }else if (refine_type == Type::CUBE){
        fstream << "refine_type: CUBE\n";
        fstream << "min_corner: [";
        for (int i = 0; i < 3; i++){
          fstream << min_corner[i] << ", ";
        }
        fstream << "]\n";
        fstream << "max_corner: [";
        for (int i = 0; i < 3; i++){
          fstream << max_corner[i] << ", ";
        }
        fstream << "]\n";
      }else if (refine_type == Type::SPHERE){
        fstream << "refine_type: SPHERE\n";
        fstream << "center_sphere: [";
        for (int i = 0; i < 3; i++){
          fstream << center_sphere[i] << ", ";
        }
        fstream << "]\n";
        fstream << "radius_sphere: " << radius_sphere << "\n";
        fstream << "radius_sphere_in: " << radius_sphere_in << "\n";
      }else if (refine_type == Type::CYLINDER){
        fstream << "refine_type: CYLINDER\n";
        fstream << "min_corner: [";
        for (int i = 0; i < 3; i++){
          fstream << min_corner[i] << ", ";
        }
        fstream << "]\n";
        fstream << "max_corner: [";
        for (int i = 0; i < 3; i++){
          fstream << max_corner[i] << ", ";
        }
        fstream << "]\n";

        fstream << "radius_cylinder: " << radius_cylinder << "\n";
        fstream << "radius_cylinder_in: " << radius_cylinder_in << "\n";
      }else if (refine_type == Type::MESHOBJECT){
        fstream << "refine_type: MESHOBJECT\n";
      }else if (refine_type == Type::MESHOBJECT_2D){
        fstream << "refine_type: MESHOBJECT_2D\n";
      }

      fstream << "shift: [";
      for (int i = 0; i < 3; i++){
        fstream << shift[i] << ", ";
      }
      fstream << "]\n";

      fstream << "forRetain: " << forRetain << "\n";
      fstream << "refine_region_lvl: " << refine_region_lvl << "\n";
      fstream << "refine_region_lvl_boundary: " << refine_region_lvl_boundary << "\n";
      fstream << "mesh_path: " << mesh_path << "\n";
    }
  }

protected:
  Type refine_type = INVALID;
  // for sphere
  ZEROPTV center_sphere;
  double radius_sphere = 0.0;
  double radius_sphere_in = 0.0;
  // for cube
  ZEROPTV min_corner;
  ZEROPTV max_corner;
  // for cylinder
  //  ZEROPTV min_corner;
  //  ZEROPTV max_corner;
  double radius_cylinder = 0.0;
  double radius_cylinder_in = 0.0;
  static Type read_type(const std::string &str){
    if (str == "sphere"){
      return SPHERE;
    }else if (str == "cube"){
      return CUBE;
    }else if (str == "cylinder"){
      return CYLINDER;
    }else if (str == "meshobject"){
      return MESHOBJECT;
    }else if (str == "meshobject_2d"){
      return MESHOBJECT_2D;
    }else
      throw TALYFEMLIB::TALYException() << "Invalid Regional refinement type";
  }
};

/**
 * Parameters for Carved out geometry
 */
struct CarvedOutGeom{
  enum Type{
    INVALID = 0,
    SPHERE = 1,
    PILLAR = 2,
    MESHOBJECT = 3,
    MESHOBJECT_2D = 4,
    CYLINDER = 5,
    CUBE = 6,
    CIRCLE_2D_VOXEL = 7,
    SPHERE_3D_VOXEL = 8,
    BOX_2D_VOXEL = 9,
    CUBE_3D_VOXEL = 10,
  };
  enum FileFormat{
    NOTKNOWN = 0,
    GMSH = 1,
    STL = 2,
  };
  enum BCType{
    INVALID_BC = 0,
    DIRICHLET = 1,
    NEUMANN = 2,
    ROBIN = 3,
    WEAK = 4,
    SBM = 5,
    NEUMANN_SBM = 6
  };
  enum InoutTYPE{
    UNKNOWN = -1,
    PRIMITIVE = 0,
    RT = 1,
  };
  enum PrescribedMov{
    STATIONARY = 0,
    ROTATION = 1,
    TRANSALATION = 2,
  };
  ///< path to surface mesh (currently must be triangular)
  std::string mesh_path;
  ///< name of the geometry (used for printing file and etc..)
  std::string name;
  ///< level of gauss point split for triangles
  unsigned gp_level = 0;
  ///< file format depending on the file extension
  FileFormat fileformat = NOTKNOWN;
  ///< type of geometry, controls which analytical in/out function to use
  Type type = INVALID;
  ///< type for checking in_out
  InoutTYPE io_type = UNKNOWN;
  ///< refinement level for future use
  unsigned int refineLevel = 0;
  ///< initial displacement for the geometry (used only once to move geometry to desired location)
  ZEROPTV InitialDisplacement;
  ///< if postprocessing
  bool ifPostprocess = true;
  ///< retain inside or outside (default is false == retain outside)
  bool outer_boundary = false;

  /// variables depending on type...
  ZEROPTV center_of_mass;
  ///< radius for sphere or cylinder types
  DENDRITE_REAL radius = 0.0;
  ///< cylinder orientation, used for in_out test
  int cylinderDir = 2;
  double height = -1.0;
  ZEROPTV bottom_center;
  ///< first one is bottom left back corner, the second one is dimension in x-y-z
  std::vector<ZEROPTV> cube_dim{2};

  /// auto refine for IMGA loop
  GeomRefinement geomRefine;

  /// boundary conditions for geometry
  std::vector<CarvedOutGeom::BCType> bc_type_V = {};
  std::vector<unsigned int> bid_V = {};
  std::vector<DENDRITE_REAL> dirichlet_V = {};
  std::vector<DENDRITE_REAL> flux_V = {};
  std::vector<DENDRITE_REAL> G_constant_V = {};
  std::vector<DENDRITE_REAL> a_constant_V = {};

  bool is_static = true;
  std::vector<bool> translation_dof;
  bool if_buoyancy = false;
  bool if_rotation = false;
  DENDRITE_REAL acc_limiter = 1e6;
  DENDRITE_REAL rho = 1.0;

  ZEROPTV ic_vel;
  ZEROPTV ic_omega;
  DENDRITE_REAL until_time = -1.0;
  DENDRITE_REAL moving_until_time = -1.0;
  ZEROPTV bounding_min;
  ZEROPTV bounding_max;

  PrescribedMov move_type = PrescribedMov::STATIONARY;
  ZEROPTV rotation_axis = {1.0, 0.0, 0.0};
  DENDRITE_REAL rotation_speed = 0.0;
  ZEROPTV translation_speed = {0.0, 0.0, 0.0};

  std::vector<DENDRITE_REAL> getBC(int dof) const{
    if (bc_type_V[dof] == CarvedOutGeom::BCType::DIRICHLET || bc_type_V[dof] == CarvedOutGeom::BCType::WEAK || bc_type_V[dof] == CarvedOutGeom::BCType::SBM){
      return std::vector<DENDRITE_REAL>{dirichlet_V.at(dof)};
    }
    if (bc_type_V[dof] == CarvedOutGeom::BCType::NEUMANN || bc_type_V[dof] == CarvedOutGeom::BCType::NEUMANN_SBM){
      return std::vector<DENDRITE_REAL>{flux_V.at(dof)};
    }
    if (bc_type_V[dof] == CarvedOutGeom::BCType::ROBIN){
      return std::vector<DENDRITE_REAL>{G_constant_V.at(dof), a_constant_V.at(dof)};
    }
  }

  void read_from_config(const libconfig::Setting &root){
    type = str_to_type(root["type"]);
    if (type != Type::CIRCLE_2D_VOXEL && type != Type::SPHERE_3D_VOXEL and
        type != Type::BOX_2D_VOXEL && type != Type::CUBE_3D_VOXEL){
      mesh_path = (const char *)root["mesh_path"];
      if (root.exists("name")){
        name = (const char *)root["name"];
      }else{
        if (mesh_path.find_last_of('/')){
          name = mesh_path.substr(mesh_path.find_last_of('/') + 1,
                                  mesh_path.find_last_of('.') - mesh_path.find_last_of('/') - 1);
        }else{
          name = mesh_path.substr(0, mesh_path.find_last_of('.') - 1);
        }
      }
      fileformat = mesh_path_to_file_format(mesh_path);
    }else{
      name = (const char *)root["name"];
    }

    if (root.exists("gp_level")){
      gp_level = (int)root["gp_level"];
    }

    if (type != Type::CIRCLE_2D_VOXEL && type != Type::SPHERE_3D_VOXEL and
        type != Type::BOX_2D_VOXEL && type != Type::CUBE_3D_VOXEL){
      ReadZEROPTV(root, "position", InitialDisplacement);
    }
    
    io_type = type_to_iotype(type);
    if (root.exists("refineLevel")){
      refineLevel = (unsigned int)root["refineLevel"];
    }

    // for IMGA loop
    geomRefine.maxSplitIteration = 100;
    geomRefine.octantLevel = 3;
    geomRefine.ratioArea = 0.25;

    if (root.exists("ifPostprocess")){
      ifPostprocess = (bool)root["ifPostprocess"];
    }
    if (root.exists("outer_boundary")){
      outer_boundary = (bool)root["outer_boundary"];
    }
    
    assert(type == CarvedOutGeom::MESHOBJECT || type == CarvedOutGeom::MESHOBJECT_2D);

    const libconfig::Setting &bc_dof = root["bc_type_V"];
    for (int i = 0; i < bc_dof.getLength(); ++i){
      std::string a = bc_dof[i];
      CarvedOutGeom::BCType temp = str_to_bctype(bc_dof[i]);
      bc_type_V.push_back(temp);
    }
    /*
    int d_iter = 0, n_iter = 0, r_iter = 0;
    for (int i = 0; i < bc_type_V.size(); i++){
      if (bc_type_V.at(i) == CarvedOutGeom::BCType::DIRICHLET || bc_type_V.at(i) == CarvedOutGeom::BCType::WEAK || bc_type_V.at(i) == CarvedOutGeom::BCType::SBM){
        const libconfig::Setting &temp1 = root["dirichlet_V"];
        dirichlet_V.push_back(DENDRITE_REAL(temp1[d_iter++]));
        flux_V.push_back(-100.0);
        G_constant_V.push_back(-100.0);
        a_constant_V.push_back(-100.0);
      }
      if (bc_type_V.at(i) == CarvedOutGeom::BCType::NEUMANN || bc_type_V.at(i) == CarvedOutGeom::BCType::NEUMANN_SBM){
        dirichlet_V.push_back(-100.0);
        const libconfig::Setting &temp2 = root["flux_V"];
        flux_V.push_back(DENDRITE_REAL(temp2[n_iter++]));
        G_constant_V.push_back(-100.0);
        a_constant_V.push_back(-100.0);
      }
      if (bc_type_V.at(i) == CarvedOutGeom::BCType::ROBIN){
        dirichlet_V.push_back(-100.0);
        flux_V.push_back(-100.0);
        const libconfig::Setting &temp3 = root["G_constant_V"];
        const libconfig::Setting &temp4 = root["a_constant_V"];
        G_constant_V.push_back(DENDRITE_REAL(temp3[r_iter]));
        a_constant_V.push_back(DENDRITE_REAL(temp4[r_iter++]));
      }
    }
    */

  }

protected:
  void checkInput(){
    // TODO
  }

  /// read mesh type
  Type str_to_type(const std::string &str) const{
    if (str == "sphere") {
      return Type::SPHERE;
    }else if (str == "pillar"){
      return Type::PILLAR;
    }else if (str == "cylinder"){
      return Type::CYLINDER;
    }else if (str == "cube") {
      return Type::CUBE;
    }else if (str == "meshobject"){
      return Type::MESHOBJECT;
    }else if (str == "meshobject_2d"){
      return Type::MESHOBJECT_2D;
    }else if (str == "circle_2d"){
      return Type::CIRCLE_2D_VOXEL;
    }else if (str == "sphere_3d") {
      return Type::SPHERE_3D_VOXEL;
    }else if (str == "box_2d") {
      return Type::BOX_2D_VOXEL;
    }else if (str == "cube_3d"){
      return Type::CUBE_3D_VOXEL;
    }else{
      throw TALYFEMLIB::TALYException() << "Invalid geometry type '" << str
                                        << "' (expected sphere, pillar, cylinder cube or meshobject(2D) )"
                                        << "\n for voxel, circle_2d or sphere_3d";
    }
  }

  FileFormat mesh_path_to_file_format(const std::string &str) const{
    if (str.substr(str.find_last_of('.') + 1) == "msh"){
      return FileFormat::GMSH;
    }else if (str.substr(str.find_last_of('.') + 1) == "stl"){
      return FileFormat::STL;
    } else{
      throw TALYFEMLIB::TALYException() << "Invalid file extension '" << str.substr(str.find_last_of('.') + 1)
                                        << "' (support .msh, .stl)";
    }
  }

  InoutTYPE type_to_iotype(const Type &type) const{
    if (type == Type::MESHOBJECT || type == Type::MESHOBJECT_2D){
      return RT;
    } else{
      return PRIMITIVE;
    }
  }

  /// read bc type
  BCType str_to_bctype(const std::string &str) const{
    if (str == "dirichlet"){
      return BCType::DIRICHLET;
    }else if (str == "neumann"){
      return BCType::NEUMANN;
    } else if (str == "robin"){
      return BCType::ROBIN;
    }else if (str == "weak"){
      return BCType::WEAK;
    } else if (str == "sbm") {
      return BCType::SBM;
    }else if (str == "neumann_sbm"){
        return  BCType::NEUMANN_SBM;
    } else{
      throw TALYFEMLIB::TALYException() << "Invalid bounday condition type '" << str
                                        << "' (expected dirichlet or neumann)";
    }
  }
};

/**
 * limiter
 */
struct Limiter{

  void read_from_config(const libconfig::Setting &root){
    if (root.exists("lb")){
      ReadVectorRoot(root, "lb", lb);
      if (lb.size() != heat3dNodeData::NUM_VARS){
        throw TALYException() << "lb has wrong size.";
      }
    }else{
      lb = std::vector<double>(heat3dNodeData::NUM_VARS, -std::numeric_limits<PetscScalar>::infinity());
    }
    
    if (root.exists("ub")){
      ReadVectorRoot(root, "ub", ub);
      if (ub.size() != heat3dNodeData::NUM_VARS){
        throw TALYException() << "ub has wrong size.";
      }
    }else{
      ub = std::vector<double>(heat3dNodeData::NUM_VARS, std::numeric_limits<PetscScalar>::infinity());
    }
    manual_limiter = true;
  }
  bool manual_limiter = false;
  std::vector<PetscScalar> lb;
  std::vector<PetscScalar> ub;
};

