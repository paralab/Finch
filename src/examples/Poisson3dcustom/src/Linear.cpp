//This file was generated by Finch.

/*

*/
// coef__v_1 = refel.Q'; // test function.
double* coef__f_1 = new double[nPe];
m_uiOctDA->getElementNodalValues(m_uiOctDA->getVecPointerToDof(grandDofVecPtr, VAR::M_UIcoef__f_1, false,false), coef__f_1, m_uiOctDA->curr(), m_uiDof);

// Allocate temporary storage for each term.
double* out_1 = new double[nPe];

double* rhscoefvec = new double[nPe];
for(int coefi=0; coefi<nPe; coefi++){
    rhscoefvec[coefi] = coef__f_1[coefi];
}
// For RHS, multiply by refel.Q to interpolate to quadrature points.
DENDRO_TENSOR_IIAX_APPLY_ELEM(nrp,Q1d,rhscoefvec,imV1);
DENDRO_TENSOR_IAIX_APPLY_ELEM(nrp,Q1d,imV1,imV2);
DENDRO_TENSOR_AIIX_APPLY_ELEM(nrp,Q1d,imV2,out_1);
 delete rhscoefvec;

// Multiply quadrature weights, geometric factors and coefficients.
for(unsigned int k=0;k<(eleOrder+1);k++){
    for(unsigned int j=0;j<(eleOrder+1);j++){
        for(unsigned int i=0;i<(eleOrder+1);i++){
out_1[(k*nrp+j)*nrp+i]*=((Jx*Jy*Jz)*W1d[i]*W1d[j]*W1d[k]);

        }
    }
}

// multiply by test functions
// Multiply by test function factor: v_1
DENDRO_TENSOR_IIAX_APPLY_ELEM(nrp,QT1d,out_1,imV1);
DENDRO_TENSOR_IAIX_APPLY_ELEM(nrp,QT1d,imV1,imV2);
DENDRO_TENSOR_AIIX_APPLY_ELEM(nrp,QT1d,imV2,out_1);


// Combine all of the terms into the output.
for(unsigned int i=0;i<nPe;i++){
    out[i]=out_1[i];
}
delete [] coef__f_1;
delete [] out_1;
